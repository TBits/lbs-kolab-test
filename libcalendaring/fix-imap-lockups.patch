commit 9b09d89342ea522cf356d90649465e93ec743ba4
Author: Jeroen van Meeuwen (Kolab Systems) <vanmeeuwen@kolabsys.com>
Date:   Mon Oct 14 17:45:31 2013 +0200

    Fix imap lockups.patch

diff --git a/kdecore/CMakeLists.txt b/kdecore/CMakeLists.txt
index f543f0e..7cdff03 100644
--- a/kdecore/CMakeLists.txt
+++ b/kdecore/CMakeLists.txt
@@ -721,3 +721,5 @@ install(FILES
 #    DESTINATION  ${SERVICETYPES_INSTALL_DIR}
 # )
 
+add_subdirectory(includes)
+
diff --git a/kdecore/includes/CMakeLists.txt b/kdecore/includes/CMakeLists.txt
new file mode 100644
index 0000000..2a10c50
--- /dev/null
+++ b/kdecore/includes/CMakeLists.txt
@@ -0,0 +1,34 @@
+
+macro(install_headers _dir)
+  install( DIRECTORY ${_dir} DESTINATION ${INCLUDE_INSTALL_DIR} )
+endmacro()
+
+macro(create_header _file _path _header)
+    #For installation
+    set(CAMELCASE_INCLUDE_PATH "../${_header}")
+    configure_file(config-CamelCaseInclude.cmake ${CMAKE_CURRENT_BINARY_DIR}/KDE/${_file})
+    #For including from the kdepimlibs stuff
+    set(CAMELCASE_INCLUDE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/../${_path}/${_header}")
+    configure_file(config-CamelCaseInclude.cmake ${CMAKE_CURRENT_BINARY_DIR}/includes/KDE/${_file})
+endmacro()
+
+create_header(KCalendarSystem date kcalendarsystem.h)
+create_header(KConfig config kconfig.h)
+create_header(KCodecs text kcodecs.h)
+create_header(KConfigGroup config kconfiggroup.h)
+create_header(KDateTime date kdatetime.h)
+create_header(KDebug io kdebug.h)
+create_header(KGlobal kernel kglobal.h)
+create_header(KJob jobs kjob.h)
+create_header(KLocale localization klocale.h)
+create_header(KMimeType services kmimetype.h)
+create_header(KRandom util krandom.h)
+create_header(KSaveFile io ksavefile.h)
+create_header(KStandardDirs kernel kstandarddirs.h)
+create_header(KSystemTimeZone date ksystemtimezone.h)
+create_header(KTemporaryFile io ktemporaryfile.h)
+create_header(KTimeZone date ktimezone.h)
+create_header(KUrl io kurl.h)
+create_header(KLocalizedString localization klocalizedstring.h)
+
+install_headers(${CMAKE_CURRENT_BINARY_DIR}/KDE)
diff --git a/kdecore/includes/config-CamelCaseInclude.cmake b/kdecore/includes/config-CamelCaseInclude.cmake
new file mode 100644
index 0000000..b6bb3e9
--- /dev/null
+++ b/kdecore/includes/config-CamelCaseInclude.cmake
@@ -0,0 +1,2 @@
+#include "${CAMELCASE_INCLUDE_PATH}"
+
diff --git a/kdecore/network/ktcpsocket.cpp b/kdecore/network/ktcpsocket.cpp
index 17b84d1..cdffccf 100644
--- a/kdecore/network/ktcpsocket.cpp
+++ b/kdecore/network/ktcpsocket.cpp
@@ -63,7 +63,12 @@ static QSsl::SslProtocol qSslProtocolFromK(KTcpSocket::SslVersion sslVersion)
         return QSsl::AnyProtocol;
     }
     //does it contain any valid protocol?
-    if (!(sslVersion & (KTcpSocket::SslV2 | KTcpSocket::SslV3 | KTcpSocket::TlsV1))) {
+    KTcpSocket::SslVersions validVersions (KTcpSocket::SslV2 | KTcpSocket::SslV3 | KTcpSocket::TlsV1);
+#if QT_VERSION >= 0x040800
+    validVersions |= KTcpSocket::TlsV1SslV3;
+    validVersions |= KTcpSocket::SecureProtocols;
+#endif
+    if (!(sslVersion & validVersions)) {
         return QSsl::UnknownProtocol;
     }
 
@@ -316,6 +321,8 @@ public:
             return KTcpSocket::NetworkError;
         case QAbstractSocket::UnsupportedSocketOperationError:
             return KTcpSocket::UnsupportedSocketOperationError;
+        case QAbstractSocket::SslHandshakeFailedError:
+            return KTcpSocket::SslHandshakeFailedError;
         case QAbstractSocket::DatagramTooLargeError:
             //we don't do UDP
         case QAbstractSocket::AddressInUseError:
diff --git a/kdecore/network/ktcpsocket.h b/kdecore/network/ktcpsocket.h
index 58dfa2c..c281b3e 100644
--- a/kdecore/network/ktcpsocket.h
+++ b/kdecore/network/ktcpsocket.h
@@ -175,7 +175,8 @@ public:
         SocketResourceError,
         SocketTimeoutError,
         NetworkError,
-        UnsupportedSocketOperationError
+        UnsupportedSocketOperationError,
+        SslHandshakeFailedError
     };
 /*
 The following is based on reading the OpenSSL interface code of both QSslSocket
diff --git a/kimap/CMakeLists.txt b/kimap/CMakeLists.txt
index e8a7b79..978c5ac 100644
--- a/kimap/CMakeLists.txt
+++ b/kimap/CMakeLists.txt
@@ -41,7 +41,12 @@ include_directories(${QT_INCLUDES})
 #include(GenerateExportHeader)
 
 
-include_directories( ../kdecore ../ ${CMAKE_CURRENT_BINARY_DIR})
+include_directories( ../kdecore 
+    ${CMAKE_CURRENT_BINARY_DIR}/../kdecore/includes/includes
+    ${CMAKE_CURRENT_BINARY_DIR}/../kdecore/includes/includes/KDE
+    ../ 
+    ${CMAKE_CURRENT_BINARY_DIR}
+)
 
 
 
diff --git a/kimap/acl.cpp b/kimap/acl.cpp
index 980538b..d0bf3e2 100644
--- a/kimap/acl.cpp
+++ b/kimap/acl.cpp
@@ -21,7 +21,7 @@
 
 #include <QtCore/QByteArray>
 #include <QtCore/QMap>
-#include <kglobal.h>
+#include <KDE/KGlobal>
 
 namespace KIMAP {
 namespace Acl {
@@ -29,8 +29,7 @@ namespace Acl {
 class RightsMap
 {
   public:
-    RightsMap()
-    {
+    RightsMap() {
       map['l'] = Lookup;
       map['r'] = Read;
       map['s'] = KeepSeen;
@@ -60,7 +59,7 @@ class RightsMap
     QMap<char, Right> map;
 };
 
-Q_GLOBAL_STATIC(RightsMap, globalRights)
+K_GLOBAL_STATIC( RightsMap, globalRights )
 
 }
 }
@@ -69,17 +68,18 @@ KIMAP::Acl::Rights KIMAP::Acl::rightsFromString( const QByteArray &string )
 {
   Rights result;
 
-  if ( string.isEmpty() )
+  if ( string.isEmpty() ) {
     return result;
+  }
 
   int pos = 0;
-  if ( string[0] == '+' || string[0]== '-') { // Skip modifier if any
+  if ( string[0] == '+' || string[0] == '-' ) { // Skip modifier if any
     pos++;
   }
 
   for ( int i = pos; i < string.size(); i++ ) {
-    if ( globalRights()->map.contains( string[i] ) ) {
-      result|= globalRights()->map[string[i]];
+    if ( globalRights->map.contains( string[i] ) ) {
+      result|= globalRights->map[string[i]];
     }
   }
 
@@ -90,9 +90,9 @@ QByteArray KIMAP::Acl::rightsToString( Rights rights )
 {
   QByteArray result;
 
-  for ( int right = Lookup; right<=Custom9; right<<=1 ) {
+  for ( int right = Lookup; right <= Custom9; right <<= 1 ) {
     if ( rights & right ) {
-      result+= globalRights()->map.key( (Right)right );
+      result += globalRights->map.key( (Right)right );
     }
   }
 
@@ -125,3 +125,5 @@ KIMAP::Acl::Rights KIMAP::Acl::denormalizedRights( KIMAP::Acl::Rights rights )
   return denormalized;
 }
 
+#include "acl.moc"
+
diff --git a/kimap/acl.h b/kimap/acl.h
index 40e738f..2df610c 100644
--- a/kimap/acl.h
+++ b/kimap/acl.h
@@ -89,17 +89,19 @@ enum Right {
   Custom9       = 0x800000  /**< Server-specific right 9 */
 };
 
-Q_DECLARE_FLAGS(Rights, Right)
+Q_DECLARE_FLAGS( Rights, Right )
 
 /**
  * Returns a rights mask that has no obsolete members anymore, i.e. obsolete flags are removed and
  * replaced by their successors.
+ * @param rights set of #Rights flags to normalize
  * @since 4.6
  */
 KIMAP_EXPORT Rights normalizedRights( Rights rights );
 
 /**
  * Returns a rights mask that contains both obsolete and new flags if one of them is set.
+ * @param rights set of #Rights flags to augment
  * @since 4.6
  */
 KIMAP_EXPORT Rights denormalizedRights( Rights rights );
diff --git a/kimap/acljobbase.cpp b/kimap/acljobbase.cpp
index 9bfe29a..5df4420 100644
--- a/kimap/acljobbase.cpp
+++ b/kimap/acljobbase.cpp
@@ -22,8 +22,8 @@
 #include "message_p.h"
 #include "session_p.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 
 using namespace KIMAP;
 
@@ -56,7 +56,7 @@ void AclJobBasePrivate::setRights(const QByteArray& rights)
     break;
   }
 
-  rightList = Acl::rightsFromString(rights);
+  rightList = Acl::rightsFromString( rights );
 }
 
 void AclJobBasePrivate::setRights(AclJobBase::AclModifier _modifier, Acl::Rights rights)
@@ -66,16 +66,13 @@ void AclJobBasePrivate::setRights(AclJobBase::AclModifier _modifier, Acl::Rights
   rightList|= rights;
 }
 
-
-
 AclJobBase::AclJobBase( Session *session )
-  : Job( *new AclJobBasePrivate(session, i18n("AclJobBase")) )
+  : Job( *new AclJobBasePrivate( session, i18n( "AclJobBase" ) ) )
 {
 }
 
-
 AclJobBase::AclJobBase( JobPrivate &dd )
-  : Job(dd)
+  : Job( dd )
 {
 
 }
@@ -84,17 +81,17 @@ AclJobBase::~AclJobBase()
 {
 }
 
-
 void AclJobBase::setMailBox( const QString &mailBox )
 {
-  Q_D(AclJobBase);
+  Q_D( AclJobBase );
   d->mailBox = mailBox;
 }
 
 QString AclJobBase::mailBox() const
 {
-  Q_D(const AclJobBase);
+  Q_D( const AclJobBase );
   return d->mailBox;
 }
 
-#include "acljobbase.moc"
\ No newline at end of file
+#include "acljobbase.moc"
+
diff --git a/kimap/acljobbase.h b/kimap/acljobbase.h
index 39616a2..fe67319 100644
--- a/kimap/acljobbase.h
+++ b/kimap/acljobbase.h
@@ -43,7 +43,7 @@ class AclJobBasePrivate;
 class KIMAP_EXPORT AclJobBase : public Job
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(AclJobBase)
+  Q_DECLARE_PRIVATE( AclJobBase )
 
   friend class SessionPrivate;
 
diff --git a/kimap/acljobbase_p.h b/kimap/acljobbase_p.h
index 7550489..45345bd 100644
--- a/kimap/acljobbase_p.h
+++ b/kimap/acljobbase_p.h
@@ -23,14 +23,14 @@
 #include "acljobbase.h"
 #include "job_p.h"
 #include "session.h"
-#include <klocale.h>
+#include <KDE/KLocalizedString>
 
 namespace KIMAP
 {
   class AclJobBasePrivate : public JobPrivate
   {
     public:
-      AclJobBasePrivate( Session *session, const QString& name ) : JobPrivate(session, name), rightList(Acl::None), modifier(AclJobBase::Change)
+      AclJobBasePrivate( Session *session, const QString& name ) : JobPrivate( session, name ), rightList( Acl::None ), modifier( AclJobBase::Change )
       {
       }
       ~AclJobBasePrivate() { }
diff --git a/kimap/appendjob.cpp b/kimap/appendjob.cpp
index b0e5c83..bda3904 100644
--- a/kimap/appendjob.cpp
+++ b/kimap/appendjob.cpp
@@ -19,7 +19,7 @@
 
 #include "appendjob.h"
 
-#include <klocale.h>
+#include <KDE/KLocalizedString>
 
 #include "job_p.h"
 #include "message_p.h"
@@ -44,7 +44,7 @@ namespace KIMAP
 using namespace KIMAP;
 
 AppendJob::AppendJob( Session *session )
-  : Job( *new AppendJobPrivate(session, i18n("Append")) )
+  : Job( *new AppendJobPrivate( session, i18n( "Append" ) ) )
 {
 }
 
@@ -54,73 +54,73 @@ AppendJob::~AppendJob()
 
 void AppendJob::setMailBox( const QString &mailBox )
 {
-  Q_D(AppendJob);
+  Q_D( AppendJob );
   d->mailBox = mailBox;
 }
 
 QString AppendJob::mailBox() const
 {
-  Q_D(const AppendJob);
+  Q_D( const AppendJob );
   return d->mailBox;
 }
 
 void AppendJob::setFlags( const QList<QByteArray> &flags)
 {
-  Q_D(AppendJob);
+  Q_D( AppendJob );
   d->flags = flags;
 }
 
 QList<QByteArray> AppendJob::flags() const
 {
-  Q_D(const AppendJob);
+  Q_D( const AppendJob );
   return d->flags;
 }
 
 void AppendJob::setContent( const QByteArray &content )
 {
-  Q_D(AppendJob);
+  Q_D( AppendJob );
   d->content = content;
 }
 
 QByteArray AppendJob::content() const
 {
-  Q_D(const AppendJob);
+  Q_D( const AppendJob );
   return d->content;
 }
 
 qint64 AppendJob::uid() const
 {
-  Q_D(const AppendJob);
+  Q_D( const AppendJob );
   return d->uid;
 }
 
 void AppendJob::doStart()
 {
-  Q_D(AppendJob);
+  Q_D( AppendJob );
 
-  QByteArray parameters = '\"'+KIMAP::encodeImapFolderName( d->mailBox.toUtf8() )+'\"';
+  QByteArray parameters = '\"' + KIMAP::encodeImapFolderName( d->mailBox.toUtf8() ) + '\"';
 
   if ( !d->flags.isEmpty() ) {
-    parameters+=" (";
+    parameters += " (";
     foreach ( const QByteArray &flag, d->flags ) {
-      parameters+= flag+' ';
+      parameters+= flag + ' ';
     }
-    parameters.chop(1);
-    parameters+=')';
+    parameters.chop( 1 );
+    parameters += ')';
   }
 
-  parameters+=" {"+QByteArray::number(d->content.size())+'}';
+  parameters += " {" + QByteArray::number( d->content.size() ) + '}';
 
   d->tags << d->sessionInternal()->sendCommand( "APPEND", parameters );
 }
 
 void AppendJob::handleResponse( const Message &response )
 {
-  Q_D(AppendJob);
+  Q_D( AppendJob );
 
   for ( QList<Message::Part>::ConstIterator it = response.responseCode.begin();
         it != response.responseCode.end(); ++it ) {
-    if ( it->toString()=="APPENDUID" ) {
+    if ( it->toString() == "APPENDUID" ) {
       it = it + 2;
       if ( it != response.responseCode.end() ) {
         d->uid = it->toString().toLongLong();
@@ -129,7 +129,7 @@ void AppendJob::handleResponse( const Message &response )
     }
   }
 
-  if (handleErrorReplies(response) == NotHandled ) {
+  if ( handleErrorReplies( response ) == NotHandled ) {
     if ( response.content[0].toString() == "+" ) {
       d->sessionInternal()->sendData( d->content );
     }
@@ -137,3 +137,4 @@ void AppendJob::handleResponse( const Message &response )
 }
 
 #include "appendjob.moc"
+
diff --git a/kimap/appendjob.h b/kimap/appendjob.h
index 9fdc2bd..d01f4f2 100644
--- a/kimap/appendjob.h
+++ b/kimap/appendjob.h
@@ -42,7 +42,7 @@ class AppendJobPrivate;
 class KIMAP_EXPORT AppendJob : public Job
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(AppendJob)
+  Q_DECLARE_PRIVATE( AppendJob )
 
   friend class SessionPrivate;
 
diff --git a/kimap/capabilitiesjob.cpp b/kimap/capabilitiesjob.cpp
index b07e1b9..a9b52dc 100644
--- a/kimap/capabilitiesjob.cpp
+++ b/kimap/capabilitiesjob.cpp
@@ -19,7 +19,7 @@
 
 #include "capabilitiesjob.h"
 
-#include <klocale.h>
+#include <KDE/KLocalizedString>
 
 #include "job_p.h"
 #include "message_p.h"
@@ -30,7 +30,7 @@ namespace KIMAP
   class CapabilitiesJobPrivate : public JobPrivate
   {
     public:
-      CapabilitiesJobPrivate( Session *session,  const QString& name ) : JobPrivate(session, name) { }
+      CapabilitiesJobPrivate( Session *session,  const QString& name ) : JobPrivate( session, name ) { }
       ~CapabilitiesJobPrivate() { }
 
       QStringList capabilities;
@@ -40,7 +40,7 @@ namespace KIMAP
 using namespace KIMAP;
 
 CapabilitiesJob::CapabilitiesJob( Session *session )
-  : Job( *new CapabilitiesJobPrivate(session, i18n("Capabilities")) )
+  : Job( *new CapabilitiesJobPrivate( session, i18n( "Capabilities" ) ) )
 {
 }
 
@@ -50,29 +50,30 @@ CapabilitiesJob::~CapabilitiesJob()
 
 QStringList CapabilitiesJob::capabilities() const
 {
-  Q_D(const CapabilitiesJob);
+  Q_D( const CapabilitiesJob );
   return d->capabilities;
 }
 
 void CapabilitiesJob::doStart()
 {
-  Q_D(CapabilitiesJob);
+  Q_D( CapabilitiesJob );
   d->tags << d->sessionInternal()->sendCommand( "CAPABILITY" );
 }
 
 void CapabilitiesJob::handleResponse( const Message &response )
 {
 
-  Q_D(CapabilitiesJob);
-  if (handleErrorReplies(response) == NotHandled) {
-    if ( response.content.size() >= 2
-           && response.content[1].toString()=="CAPABILITY" ) {
-      for (int i=2; i<response.content.size(); ++i) {
+  Q_D( CapabilitiesJob );
+  if ( handleErrorReplies( response ) == NotHandled ) {
+    if ( response.content.size() >= 2 &&
+         response.content[1].toString() == "CAPABILITY" ) {
+      for ( int i = 2; i < response.content.size(); ++i ) {
         d->capabilities << response.content[i].toString().toUpper();
       }
-      emit capabilitiesReceived(d->capabilities);
+      emit capabilitiesReceived( d->capabilities );
     }
   }
 }
 
 #include "capabilitiesjob.moc"
+
diff --git a/kimap/capabilitiesjob.h b/kimap/capabilitiesjob.h
index 0306f26..42ab3b1 100644
--- a/kimap/capabilitiesjob.h
+++ b/kimap/capabilitiesjob.h
@@ -45,7 +45,7 @@ class CapabilitiesJobPrivate;
 class KIMAP_EXPORT CapabilitiesJob : public Job
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(CapabilitiesJob)
+  Q_DECLARE_PRIVATE( CapabilitiesJob )
 
   friend class SessionPrivate;
 
diff --git a/kimap/closejob.cpp b/kimap/closejob.cpp
index ea6416f..a59f386 100644
--- a/kimap/closejob.cpp
+++ b/kimap/closejob.cpp
@@ -19,7 +19,7 @@
 
 #include "closejob.h"
 
-#include <klocale.h>
+#include <KDE/KLocalizedString>
 
 #include "job_p.h"
 #include "message_p.h"
@@ -30,7 +30,7 @@ namespace KIMAP
   class CloseJobPrivate : public JobPrivate
   {
     public:
-      CloseJobPrivate( Session *session, const QString& name ) : JobPrivate(session, name) { }
+      CloseJobPrivate( Session *session, const QString& name ) : JobPrivate( session, name ) { }
       ~CloseJobPrivate() { }
   };
 }
@@ -38,7 +38,7 @@ namespace KIMAP
 using namespace KIMAP;
 
 CloseJob::CloseJob( Session *session )
-  : Job( *new CloseJobPrivate(session, i18n("Close")) )
+  : Job( *new CloseJobPrivate( session, i18n( "Close" ) ) )
 {
 }
 
@@ -48,8 +48,9 @@ CloseJob::~CloseJob()
 
 void CloseJob::doStart()
 {
-  Q_D(CloseJob);
+  Q_D( CloseJob );
   d->tags << d->sessionInternal()->sendCommand( "CLOSE" );
 }
 
 #include "closejob.moc"
+
diff --git a/kimap/closejob.h b/kimap/closejob.h
index 3cadc72..35d64bd 100644
--- a/kimap/closejob.h
+++ b/kimap/closejob.h
@@ -52,7 +52,7 @@ class CloseJobPrivate;
 class KIMAP_EXPORT CloseJob : public Job
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(CloseJob)
+  Q_DECLARE_PRIVATE( CloseJob )
 
   friend class SessionPrivate;
 
diff --git a/kimap/copyjob.cpp b/kimap/copyjob.cpp
index 05f2efb..a07d509 100644
--- a/kimap/copyjob.cpp
+++ b/kimap/copyjob.cpp
@@ -19,8 +19,8 @@
 
 #include "copyjob.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 
 #include "job_p.h"
 #include "message_p.h"
@@ -34,7 +34,7 @@ namespace KIMAP
   class CopyJobPrivate : public JobPrivate
   {
     public:
-      CopyJobPrivate( Session *session, const QString& name ) : JobPrivate(session, name) { }
+      CopyJobPrivate( Session *session, const QString& name ) : JobPrivate( session, name ) { }
       ~CopyJobPrivate() { }
 
       QString mailBox;
@@ -47,9 +47,9 @@ namespace KIMAP
 using namespace KIMAP;
 
 CopyJob::CopyJob( Session *session )
-  : Job( *new CopyJobPrivate(session, i18n("Copy")) )
+  : Job( *new CopyJobPrivate( session, i18n( "Copy" ) ) )
 {
-  Q_D(CopyJob);
+  Q_D( CopyJob );
   d->uidBased = false;
 }
 
@@ -59,53 +59,52 @@ CopyJob::~CopyJob()
 
 void CopyJob::setMailBox( const QString &mailBox )
 {
-  Q_D(CopyJob);
+  Q_D( CopyJob );
   d->mailBox = mailBox;
 }
 
 QString CopyJob::mailBox() const
 {
-  Q_D(const CopyJob);
+  Q_D( const CopyJob );
   return d->mailBox;
 }
 
 void CopyJob::setSequenceSet( const ImapSet &set )
 {
-  Q_D(CopyJob);
+  Q_D( CopyJob );
   d->set = set;
 }
 
 ImapSet CopyJob::sequenceSet() const
 {
-  Q_D(const CopyJob);
+  Q_D( const CopyJob );
   return d->set;
 }
 
-
 void CopyJob::setUidBased( bool uidBased )
 {
-  Q_D(CopyJob);
+  Q_D( CopyJob );
   d->uidBased = uidBased;
 }
 
 bool CopyJob::isUidBased() const
 {
-  Q_D(const CopyJob);
+  Q_D( const CopyJob );
   return d->uidBased;
 }
 
 ImapSet CopyJob::resultingUids() const
 {
-  Q_D(const CopyJob);
+  Q_D( const CopyJob );
   return d->resultingUids;
 }
 
 void CopyJob::doStart()
 {
-  Q_D(CopyJob);
+  Q_D( CopyJob );
 
   QByteArray parameters = d->set.toImapSequenceSet()+' ';
-  parameters+= '\"'+KIMAP::encodeImapFolderName( d->mailBox.toUtf8() )+'\"';
+  parameters += '\"' + KIMAP::encodeImapFolderName( d->mailBox.toUtf8() ) + '\"';
 
   QByteArray command = "COPY";
   if ( d->uidBased ) {
@@ -117,11 +116,11 @@ void CopyJob::doStart()
 
 void CopyJob::handleResponse( const Message &response )
 {
-  Q_D(CopyJob);
+  Q_D( CopyJob );
 
   for ( QList<Message::Part>::ConstIterator it = response.responseCode.begin();
         it != response.responseCode.end(); ++it ) {
-    if ( it->toString()=="COPYUID" ) {
+    if ( it->toString() == "COPYUID" ) {
       it = it + 3;
       if ( it < response.responseCode.end() ) {
         d->resultingUids = ImapSet::fromImapSequenceSet( it->toString() );
@@ -134,3 +133,4 @@ void CopyJob::handleResponse( const Message &response )
 }
 
 #include "copyjob.moc"
+
diff --git a/kimap/copyjob.h b/kimap/copyjob.h
index 5e75fdc..c64bcbf 100644
--- a/kimap/copyjob.h
+++ b/kimap/copyjob.h
@@ -46,7 +46,7 @@ class CopyJobPrivate;
 class KIMAP_EXPORT CopyJob : public Job
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(CopyJob)
+  Q_DECLARE_PRIVATE( CopyJob )
 
   friend class SessionPrivate;
 
diff --git a/kimap/createjob.cpp b/kimap/createjob.cpp
index 6f25e0a..b6d486f 100644
--- a/kimap/createjob.cpp
+++ b/kimap/createjob.cpp
@@ -19,8 +19,8 @@
 
 #include "createjob.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 
 #include "job_p.h"
 #include "message_p.h"
@@ -32,7 +32,7 @@ namespace KIMAP
   class CreateJobPrivate : public JobPrivate
   {
     public:
-      CreateJobPrivate( Session *session, const QString& name ) : JobPrivate(session, name) { }
+      CreateJobPrivate( Session *session, const QString& name ) : JobPrivate( session, name ) { }
       ~CreateJobPrivate() { }
 
       QString mailBox;
@@ -42,7 +42,7 @@ namespace KIMAP
 using namespace KIMAP;
 
 CreateJob::CreateJob( Session *session )
-  : Job( *new CreateJobPrivate(session, i18n("Create")) )
+  : Job( *new CreateJobPrivate( session, i18n( "Create" ) ) )
 {
 }
 
@@ -52,20 +52,21 @@ CreateJob::~CreateJob()
 
 void CreateJob::doStart()
 {
-  Q_D(CreateJob);
-  d->tags << d->sessionInternal()->sendCommand( "CREATE", '\"'+KIMAP::encodeImapFolderName( d->mailBox.toUtf8() )+'\"' );
+  Q_D( CreateJob );
+  d->tags << d->sessionInternal()->sendCommand( "CREATE", '\"' + KIMAP::encodeImapFolderName( d->mailBox.toUtf8() ) + '\"' );
 }
 
 void CreateJob::setMailBox( const QString &mailBox )
 {
-  Q_D(CreateJob);
+  Q_D( CreateJob );
   d->mailBox = mailBox;
 }
 
 QString CreateJob::mailBox() const
 {
-  Q_D(const CreateJob);
+  Q_D( const CreateJob );
   return d->mailBox;
 }
 
 #include "createjob.moc"
+
diff --git a/kimap/createjob.h b/kimap/createjob.h
index daab478..9977898 100644
--- a/kimap/createjob.h
+++ b/kimap/createjob.h
@@ -47,7 +47,7 @@ class CreateJobPrivate;
 class KIMAP_EXPORT CreateJob : public Job
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(CreateJob)
+  Q_DECLARE_PRIVATE( CreateJob )
 
   friend class SessionPrivate;
 
diff --git a/kimap/deleteacljob.cpp b/kimap/deleteacljob.cpp
index b5ea9a9..ca3a206 100644
--- a/kimap/deleteacljob.cpp
+++ b/kimap/deleteacljob.cpp
@@ -19,8 +19,8 @@
 
 #include "deleteacljob.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 
 #include "acljobbase_p.h"
 #include "message_p.h"
@@ -32,7 +32,7 @@ namespace KIMAP
   class DeleteAclJobPrivate : public AclJobBasePrivate
   {
     public:
-      DeleteAclJobPrivate( Session *session, const QString& name ) : AclJobBasePrivate(session, name) {}
+      DeleteAclJobPrivate( Session *session, const QString& name ) : AclJobBasePrivate( session, name ) {}
       ~DeleteAclJobPrivate() { }
   };
 }
@@ -42,8 +42,8 @@ using namespace KIMAP;
 DeleteAclJob::DeleteAclJob( Session *session )
   : AclJobBase( session )
 {
-  Q_D(DeleteAclJob);
-  d->m_name = i18n("DeleteAclJob");
+  Q_D( DeleteAclJob );
+  d->m_name = i18n( "DeleteAclJob" );
 }
 
 DeleteAclJob::~DeleteAclJob()
@@ -52,21 +52,22 @@ DeleteAclJob::~DeleteAclJob()
 
 void DeleteAclJob::doStart()
 {
-  Q_D(DeleteAclJob);
+  Q_D( DeleteAclJob );
 
-  d->tags << d->sessionInternal()->sendCommand( "DELETEACL", '\"' + KIMAP::encodeImapFolderName( d->mailBox.toUtf8() ) + "\" \"" + d->id);
+  d->tags << d->sessionInternal()->sendCommand( "DELETEACL", '\"' + KIMAP::encodeImapFolderName( d->mailBox.toUtf8() ) + "\" \"" + d->id );
 }
 
 void DeleteAclJob::setIdentifier( const QByteArray &identifier )
 {
-  Q_D(DeleteAclJob);
-  d->setIdentifier(identifier);
+  Q_D( DeleteAclJob );
+  d->setIdentifier( identifier );
 }
 
 QByteArray DeleteAclJob::identifier()
 {
-  Q_D(DeleteAclJob);
+  Q_D( DeleteAclJob );
   return d->identifier();
 }
 
 #include "deleteacljob.moc"
+
diff --git a/kimap/deleteacljob.h b/kimap/deleteacljob.h
index 0f06055..7beed89 100644
--- a/kimap/deleteacljob.h
+++ b/kimap/deleteacljob.h
@@ -47,7 +47,7 @@ class DeleteAclJobPrivate;
 class KIMAP_EXPORT DeleteAclJob : public AclJobBase
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(DeleteAclJob)
+  Q_DECLARE_PRIVATE( DeleteAclJob )
 
   friend class SessionPrivate;
 
diff --git a/kimap/deletejob.cpp b/kimap/deletejob.cpp
index 59201ff..c1149ca 100644
--- a/kimap/deletejob.cpp
+++ b/kimap/deletejob.cpp
@@ -19,8 +19,8 @@
 
 #include "deletejob.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 
 #include "job_p.h"
 #include "message_p.h"
@@ -32,7 +32,7 @@ namespace KIMAP
   class DeleteJobPrivate : public JobPrivate
   {
     public:
-      DeleteJobPrivate( Session *session, const QString& name ) : JobPrivate(session, name) { }
+      DeleteJobPrivate( Session *session, const QString& name ) : JobPrivate( session, name ) { }
       ~DeleteJobPrivate() { }
 
       QString mailBox;
@@ -42,7 +42,7 @@ namespace KIMAP
 using namespace KIMAP;
 
 DeleteJob::DeleteJob( Session *session )
-  : Job( *new DeleteJobPrivate(session, i18n("Delete")) )
+  : Job( *new DeleteJobPrivate( session, i18n( "Delete" ) ) )
 {
 }
 
@@ -52,20 +52,21 @@ DeleteJob::~DeleteJob()
 
 void DeleteJob::doStart()
 {
-  Q_D(DeleteJob);
-  d->tags << d->sessionInternal()->sendCommand( "DELETE", '\"'+KIMAP::encodeImapFolderName( d->mailBox.toUtf8() )+'\"' );
+  Q_D( DeleteJob );
+  d->tags << d->sessionInternal()->sendCommand( "DELETE", '\"' + KIMAP::encodeImapFolderName( d->mailBox.toUtf8() ) + '\"' );
 }
 
 void DeleteJob::setMailBox( const QString &mailBox )
 {
-  Q_D(DeleteJob);
+  Q_D( DeleteJob );
   d->mailBox = mailBox;
 }
 
 QString DeleteJob::mailBox() const
 {
-  Q_D(const DeleteJob);
+  Q_D( const DeleteJob );
   return d->mailBox;
 }
 
-#include "deletejob.moc"
\ No newline at end of file
+#include "deletejob.moc"
+
diff --git a/kimap/deletejob.h b/kimap/deletejob.h
index 2876a90..926ee3c 100644
--- a/kimap/deletejob.h
+++ b/kimap/deletejob.h
@@ -46,7 +46,7 @@ class DeleteJobPrivate;
 class KIMAP_EXPORT DeleteJob : public Job
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(DeleteJob)
+  Q_DECLARE_PRIVATE( DeleteJob )
 
   friend class SessionPrivate;
 
diff --git a/kimap/expungejob.cpp b/kimap/expungejob.cpp
index 8da8285..63bed80 100644
--- a/kimap/expungejob.cpp
+++ b/kimap/expungejob.cpp
@@ -19,8 +19,8 @@
 
 #include "expungejob.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 
 #include "job_p.h"
 #include "message_p.h"
@@ -31,7 +31,7 @@ namespace KIMAP
   class ExpungeJobPrivate : public JobPrivate
   {
     public:
-      ExpungeJobPrivate( Session *session, const QString& name ) : JobPrivate(session, name) { }
+      ExpungeJobPrivate( Session *session, const QString& name ) : JobPrivate( session, name ) { }
       ~ExpungeJobPrivate() { }
 #if 0
       QList< int > items;
@@ -42,7 +42,7 @@ namespace KIMAP
 using namespace KIMAP;
 
 ExpungeJob::ExpungeJob( Session *session )
-  : Job( *new ExpungeJobPrivate(session, i18n("Expunge")) )
+  : Job( *new ExpungeJobPrivate( session, i18n( "Expunge" ) ) )
 {
 }
 
@@ -52,7 +52,7 @@ ExpungeJob::~ExpungeJob()
 
 void ExpungeJob::doStart()
 {
-  Q_D(ExpungeJob);
+  Q_D( ExpungeJob );
   d->tags << d->sessionInternal()->sendCommand( "EXPUNGE" );
 }
 
@@ -60,25 +60,26 @@ void ExpungeJob::handleResponse( const Message &response )
 {
 //  Q_D(ExpungeJob);
 
-  if (handleErrorReplies(response) == NotHandled) {
+  if ( handleErrorReplies( response ) == NotHandled ) {
     if ( response.content.size() >= 2 ) {
         QByteArray code = response.content[2].toString();
-        if  (code == "EXPUNGE") {
+        if ( code == "EXPUNGE" ) {
 #if 0
           QByteArray s = response.content[1].toString();
           bool ok = true;
-          int id = s.toInt(&ok);
-          if (ok) {
-            d->items.append(id);
+          int id = s.toInt( &ok );
+          if ( ok ) {
+            d->items.append( id );
           }
           //TODO error handling
 #endif
           return;
         }
     }
-    qDebug() << "Unhandled response: " << response.toString().constData();
+    kDebug() << "Unhandled response: " << response.toString().constData();
 
   }
 }
 
 #include "expungejob.moc"
+
diff --git a/kimap/expungejob.h b/kimap/expungejob.h
index 9862f59..7e2918b 100644
--- a/kimap/expungejob.h
+++ b/kimap/expungejob.h
@@ -45,7 +45,7 @@ class ExpungeJobPrivate;
 class KIMAP_EXPORT ExpungeJob : public Job
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(ExpungeJob)
+  Q_DECLARE_PRIVATE( ExpungeJob )
 
   friend class SessionPrivate;
 
diff --git a/kimap/fetchjob.cpp b/kimap/fetchjob.cpp
index 32582b2..bbb12a4 100644
--- a/kimap/fetchjob.cpp
+++ b/kimap/fetchjob.cpp
@@ -20,8 +20,8 @@
 #include "fetchjob.h"
 
 #include <QtCore/QTimer>
-#include <kdebug.h>
-#include <klocale.h>
+#include <KDE/KDebug>
+#include <KDE/KLocalizedString>
 
 #include "job_p.h"
 #include "message_p.h"
@@ -32,7 +32,7 @@ namespace KIMAP
   class FetchJobPrivate : public JobPrivate
   {
     public:
-      FetchJobPrivate( FetchJob *job, Session *session, const QString& name ) : JobPrivate( session, name ), q(job), uidBased(false) { }
+      FetchJobPrivate( FetchJob *job, Session *session, const QString& name ) : JobPrivate( session, name ), q( job ), uidBased( false ) { }
       ~FetchJobPrivate() { }
 
       void parseBodyStructure( const QByteArray &structure, int &pos, KMime::Content *content );
@@ -87,9 +87,9 @@ namespace KIMAP
 using namespace KIMAP;
 
 FetchJob::FetchJob( Session *session )
-  : Job( *new FetchJobPrivate(this, session, i18n("Fetch")) )
+  : Job( *new FetchJobPrivate( this, session, i18n( "Fetch" ) ) )
 {
-  Q_D(FetchJob);
+  Q_D( FetchJob );
   d->scope.mode = FetchScope::Content;
   connect( &d->emitPendingsTimer, SIGNAL(timeout()),
            this, SLOT(emitPendings()) );
@@ -101,38 +101,38 @@ FetchJob::~FetchJob()
 
 void FetchJob::setSequenceSet( const ImapSet &set )
 {
-  Q_D(FetchJob);
+  Q_D( FetchJob );
   Q_ASSERT( !set.toImapSequenceSet().trimmed().isEmpty() );
   d->set = set;
 }
 
 ImapSet FetchJob::sequenceSet() const
 {
-  Q_D(const FetchJob);
+  Q_D( const FetchJob );
   return d->set;
 }
 
 void FetchJob::setUidBased(bool uidBased)
 {
-  Q_D(FetchJob);
+  Q_D( FetchJob );
   d->uidBased = uidBased;
 }
 
 bool FetchJob::isUidBased() const
 {
-  Q_D(const FetchJob);
+  Q_D( const FetchJob );
   return d->uidBased;
 }
 
 void FetchJob::setScope( const FetchScope &scope )
 {
-  Q_D(FetchJob);
+  Q_D( FetchJob );
   d->scope = scope;
 }
 
 FetchJob::FetchScope FetchJob::scope() const
 {
-  Q_D(const FetchJob);
+  Q_D( const FetchJob );
   return d->scope;
 }
 
@@ -163,7 +163,7 @@ QMap<qint64, qint64> FetchJob::uids() const
 
 void FetchJob::doStart()
 {
-  Q_D(FetchJob);
+  Q_D( FetchJob );
 
   QByteArray parameters = d->set.toImapSequenceSet()+' ';
   Q_ASSERT( !parameters.trimmed().isEmpty() );
@@ -171,51 +171,51 @@ void FetchJob::doStart()
   switch ( d->scope.mode ) {
   case FetchScope::Headers:
     if ( d->scope.parts.isEmpty() ) {
-      parameters+="(RFC822.SIZE INTERNALDATE BODY.PEEK[HEADER.FIELDS (TO FROM MESSAGE-ID REFERENCES IN-REPLY-TO SUBJECT DATE)] FLAGS UID)";
+      parameters += "(RFC822.SIZE INTERNALDATE BODY.PEEK[HEADER.FIELDS (TO FROM MESSAGE-ID REFERENCES IN-REPLY-TO SUBJECT DATE)] FLAGS UID)";
     } else {
-      parameters+='(';
+      parameters += '(';
       foreach ( const QByteArray &part, d->scope.parts ) {
-        parameters+="BODY.PEEK["+part+".MIME] ";
+        parameters += "BODY.PEEK[" + part + ".MIME] ";
       }
-      parameters+="UID)";
+      parameters += "UID)";
     }
     break;
   case FetchScope::Flags:
-    parameters+="(FLAGS UID)";
+    parameters += "(FLAGS UID)";
     break;
   case FetchScope::Structure:
-    parameters+="(BODYSTRUCTURE UID)";
+    parameters += "(BODYSTRUCTURE UID)";
     break;
   case FetchScope::Content:
     if ( d->scope.parts.isEmpty() ) {
-      parameters+="(BODY.PEEK[] UID)";
+      parameters += "(BODY.PEEK[] UID)";
     } else {
-      parameters+='(';
+      parameters += '(';
       foreach ( const QByteArray &part, d->scope.parts ) {
-        parameters+="BODY.PEEK["+part+"] ";
+        parameters += "BODY.PEEK[" + part + "] ";
       }
-      parameters+="UID)";
+      parameters += "UID)";
     }
     break;
   case FetchScope::Full:
-    parameters+="(RFC822.SIZE INTERNALDATE BODY.PEEK[] FLAGS UID)";
+    parameters += "(RFC822.SIZE INTERNALDATE BODY.PEEK[] FLAGS UID)";
     break;
   case FetchScope::HeaderAndContent:
     if ( d->scope.parts.isEmpty() ) {
-      parameters+="(BODY.PEEK[] FLAGS UID)";
+      parameters += "(BODY.PEEK[] FLAGS UID)";
     } else {
-      parameters+="(BODY.PEEK[HEADER.FIELDS (TO FROM MESSAGE-ID REFERENCES IN-REPLY-TO SUBJECT DATE)]";
+      parameters += "(BODY.PEEK[HEADER.FIELDS (TO FROM MESSAGE-ID REFERENCES IN-REPLY-TO SUBJECT DATE)]";
       foreach ( const QByteArray &part, d->scope.parts ) {
-        parameters+=" BODY.PEEK["+part+".MIME] BODY.PEEK["+part+"]"; //krazy:exclude=doublequote_chars
+        parameters += " BODY.PEEK[" + part + ".MIME] BODY.PEEK[" + part + "]"; //krazy:exclude=doublequote_chars
       }
-      parameters+=" FLAGS UID)";
+      parameters += " FLAGS UID)";
     }
     break;
   }
 
   QByteArray command = "FETCH";
   if ( d->uidBased ) {
-    command = "UID "+command;
+    command = "UID " + command;
   }
 
   d->emitPendingsTimer.start( 100 );
@@ -225,21 +225,21 @@ void FetchJob::doStart()
 
 void FetchJob::handleResponse( const Message &response )
 {
-  Q_D(FetchJob);
+  Q_D( FetchJob );
 
   // We can predict it'll be handled by handleErrorReplies() so stop
   // the timer now so that result() will really be the last emitted signal.
-  if ( !response.content.isEmpty()
-       && d->tags.size() == 1
-       && d->tags.contains( response.content.first().toString() ) ) {
+  if ( !response.content.isEmpty() &&
+       d->tags.size() == 1 &&
+       d->tags.contains( response.content.first().toString() ) ) {
     d->emitPendingsTimer.stop();
     d->emitPendings();
   }
 
-  if (handleErrorReplies(response) == NotHandled ) {
-    if ( response.content.size() == 4
-           && response.content[2].toString()=="FETCH"
-           && response.content[3].type()==Message::Part::List ) {
+  if ( handleErrorReplies( response ) == NotHandled ) {
+    if ( response.content.size() == 4 &&
+         response.content[2].toString() == "FETCH" &&
+         response.content[3].type() == Message::Part::List ) {
 
       qint64 id = response.content[1].toString().toLongLong();
       QList<QByteArray> content = response.content[3].toList();
@@ -249,67 +249,69 @@ void FetchJob::handleResponse( const Message &response )
       MessageParts parts;
 
       for ( QList<QByteArray>::ConstIterator it = content.constBegin();
-            it!=content.constEnd(); ++it ) {
+            it != content.constEnd(); ++it ) {
         QByteArray str = *it;
         ++it;
 
-        if ( it==content.constEnd() ) { // Uh oh, message was truncated?
+        if ( it == content.constEnd() ) { // Uh oh, message was truncated?
           kWarning() << "FETCH reply got truncated, skipping.";
           break;
         }
 
-        if ( str=="UID" ) {
+        if ( str == "UID" ) {
           d->pendingUids[id] = it->toLongLong();
-        } else if ( str=="RFC822.SIZE" ) {
+        } else if ( str == "RFC822.SIZE" ) {
           d->pendingSizes[id] = it->toLongLong();
-        } else if ( str=="INTERNALDATE" ) {
+        } else if ( str == "INTERNALDATE" ) {
           message->date()->setDateTime( KDateTime::fromString( *it, KDateTime::RFCDate ) );
-        } else if ( str=="FLAGS" ) {
-          if ( (*it).startsWith('(') && (*it).endsWith(')') ) {
+        } else if ( str == "FLAGS" ) {
+          if ( ( *it ).startsWith( '(' ) && ( *it ).endsWith( ')' ) ) {
             QByteArray str = *it;
-            str.chop(1);
-            str.remove(0, 1);
-            d->pendingFlags[id] = str.split(' ');
+            str.chop( 1 );
+            str.remove( 0, 1 );
+            d->pendingFlags[id] = str.split( ' ' );
           } else {
             d->pendingFlags[id] << *it;
           }
-        } else if ( str=="BODYSTRUCTURE" ) {
+        } else if ( str == "BODYSTRUCTURE" ) {
           int pos = 0;
-          d->parseBodyStructure(*it, pos, message.get());
+          d->parseBodyStructure( *it, pos, message.get() );
           message->assemble();
           d->pendingMessages[id] = message;
-        } else if ( str.startsWith( "BODY[") ) { //krazy:exclude=strings
-          if ( !str.endsWith(']') ) { // BODY[ ... ] might have been split, skip until we find the ]
-            while ( !(*it).endsWith(']') ) ++it;
+        } else if ( str.startsWith( "BODY[" ) ) { //krazy:exclude=strings
+          if ( !str.endsWith( ']' ) ) { // BODY[ ... ] might have been split, skip until we find the ]
+            while ( !( *it ).endsWith( ']' ) ) {
+              ++it;
+            }
             ++it;
           }
 
           int index;
-          if ( (index=str.indexOf("HEADER"))>0 || (index=str.indexOf("MIME"))>0 ) { // headers
-            if ( str[index-1]=='.' ) {
-              QByteArray partId = str.mid( 5, index-6 );
+          if ( ( index = str.indexOf( "HEADER" ) ) > 0 || ( index = str.indexOf( "MIME" ) ) > 0 ) { // headers
+            if ( str[index-1] == '.' ) {
+              QByteArray partId = str.mid( 5, index - 6 );
               if ( !parts.contains( partId ) ) {
                   parts[partId] = ContentPtr( new KMime::Content );
               }
-              parts[partId]->setHead(*it);
+              parts[partId]->setHead( *it );
               parts[partId]->parse();
               d->pendingParts[id] = parts;
             } else {
-              message->setHead(*it);
+              message->setHead( *it );
               shouldParseMessage = true;
             }
           } else { // full payload
-            if ( str=="BODY[]" ) {
-              message->setContent( KMime::CRLFtoLF(*it) );
+            if ( str == "BODY[]" ) {
+              message->setContent( KMime::CRLFtoLF( *it ) );
               shouldParseMessage = true;
 
               d->pendingMessages[id] = message;
             } else {
-              QByteArray partId = str.mid( 5, str.size()-6 );
+              QByteArray partId = str.mid( 5, str.size() - 6 );
               if ( !parts.contains( partId ) ) {
                 parts[partId] = ContentPtr( new KMime::Content );
               }
-              parts[partId]->setBody(*it);
+              parts[partId]->setBody( *it );
               parts[partId]->parse();
 
               d->pendingParts[id] = parts;
@@ -334,21 +336,20 @@ void FetchJob::handleResponse( const Message &response )
 
 void FetchJobPrivate::parseBodyStructure(const QByteArray &structure, int &pos, KMime::Content *content)
 {
-  skipLeadingSpaces(structure, pos);
+  skipLeadingSpaces( structure, pos );
 
-  if ( structure[pos]!='(' ) {
+  if ( structure[pos] != '(' ) {
     return;
   }
 
   pos++;
 
-
-  if ( structure[pos]!='(' ) { // simple part
+  if ( structure[pos] != '(' ) { // simple part
     pos--;
     parsePart( structure, pos, content );
   } else { // multi part
-    content->contentType()->setMimeType("MULTIPART/MIXED");
-    while ( pos<structure.size() && structure[pos]=='(' ) {
+    content->contentType()->setMimeType( "MULTIPART/MIXED" );
+    while ( pos < structure.size() && structure[pos] == '(' ) {
       KMime::Content *child = new KMime::Content;
       content->addContent( child );
       parseBodyStructure( structure, pos, child );
@@ -356,17 +357,17 @@ void FetchJobPrivate::parseBodyStructure(const QByteArray &structure, int &pos,
     }
 
     QByteArray subType = parseString( structure, pos );
-    content->contentType()->setMimeType( "MULTIPART/"+subType );
+    content->contentType()->setMimeType( "MULTIPART/" + subType );
 
     QByteArray parameters = parseSentence( structure, pos ); // FIXME: Read the charset
-    if (parameters.contains("BOUNDARY") ) {
-      content->contentType()->setBoundary(parameters.remove(0, parameters.indexOf("BOUNDARY") + 11).split('\"')[0]);
+    if ( parameters.contains( "BOUNDARY" ) ) {
+      content->contentType()->setBoundary( parameters.remove( 0, parameters.indexOf( "BOUNDARY" ) + 11 ).split( '\"' )[0] );
     }
 
     QByteArray disposition = parseSentence( structure, pos );
-    if ( disposition.contains("INLINE") ) {
+    if ( disposition.contains( "INLINE" ) ) {
       content->contentDisposition()->setDisposition( KMime::Headers::CDinline );
-    } else if ( disposition.contains("ATTACHMENT") ) {
+    } else if ( disposition.contains( "ATTACHMENT" ) ) {
       content->contentDisposition()->setDisposition( KMime::Headers::CDattachment );
     }
 
@@ -374,7 +375,7 @@ void FetchJobPrivate::parseBodyStructure(const QByteArray &structure, int &pos,
   }
 
   // Consume what's left
-  while ( pos<structure.size() && structure[pos]!=')' ) {
+  while ( pos < structure.size() && structure[pos] != ')' ) {
     skipLeadingSpaces( structure, pos );
     parseSentence( structure, pos );
     skipLeadingSpaces( structure, pos );
@@ -385,7 +386,7 @@ void FetchJobPrivate::parseBodyStructure(const QByteArray &structure, int &pos,
 
 void FetchJobPrivate::parsePart( const QByteArray &structure, int &pos, KMime::Content *content )
 {
-  if ( structure[pos]!='(' ) {
+  if ( structure[pos] != '(' ) {
     return;
   }
 
@@ -394,7 +395,7 @@ void FetchJobPrivate::parsePart( const QByteArray &structure, int &pos, KMime::C
   QByteArray mainType = parseString( structure, pos );
   QByteArray subType = parseString( structure, pos );
 
-  content->contentType()->setMimeType( mainType+'/'+subType );
+  content->contentType()->setMimeType( mainType + '/' + subType );
 
   parseSentence( structure, pos ); // Ditch the parameters... FIXME: Read it to get charset and name
   parseString( structure, pos ); // ... and the id
@@ -406,20 +407,20 @@ void FetchJobPrivate::parsePart( const QByteArray &structure, int &pos, KMime::C
   parseString( structure, pos ); // ... and the line count
 
   QByteArray disposition = parseSentence( structure, pos );
-  if ( disposition.contains("INLINE") ) {
+  if ( disposition.contains( "INLINE" ) ) {
     content->contentDisposition()->setDisposition( KMime::Headers::CDinline );
-  } else if ( disposition.contains("ATTACHMENT") ) {
+  } else if ( disposition.contains( "ATTACHMENT" ) ) {
     content->contentDisposition()->setDisposition( KMime::Headers::CDattachment );
   }
-  if ( (content->contentDisposition()->disposition() == KMime::Headers::CDattachment
-        || content->contentDisposition()->disposition() == KMime::Headers::CDinline)
-       && disposition.contains("FILENAME") ) {
-    QByteArray filename = disposition.remove(0, disposition.indexOf("FILENAME") + 11).split('\"')[0];
+  if ( ( content->contentDisposition()->disposition() == KMime::Headers::CDattachment ||
+         content->contentDisposition()->disposition() == KMime::Headers::CDinline ) &&
+       disposition.contains( "FILENAME" ) ) {
+    QByteArray filename = disposition.remove( 0, disposition.indexOf( "FILENAME" ) + 11 ).split( '\"' )[0];
     content->contentDisposition()->setFilename( filename );
   }
 
   // Consume what's left
-  while ( pos<structure.size() && structure[pos]!=')' ) {
+  while ( pos < structure.size() && structure[pos] != ')' ) {
     skipLeadingSpaces( structure, pos );
     parseSentence( structure, pos );
     skipLeadingSpaces( structure, pos );
@@ -433,7 +434,7 @@ QByteArray FetchJobPrivate::parseSentence( const QByteArray &structure, int &pos
 
   skipLeadingSpaces( structure, pos );
 
-  if ( structure[pos]!='(' ) {
+  if ( structure[pos] != '(' ) {
     return parseString( structure, pos );
   }
 
@@ -458,12 +459,12 @@ QByteArray FetchJobPrivate::parseSentence( const QByteArray &structure, int &pos
       stack--;
       break;
     default:
-      skipLeadingSpaces(structure, pos);
-      parseString(structure, pos);
-      skipLeadingSpaces(structure, pos);
+      skipLeadingSpaces( structure, pos );
+      parseString( structure, pos );
+      skipLeadingSpaces( structure, pos );
       break;
     }
-  } while ( pos<structure.size() && stack!=0 );
+  } while ( pos < structure.size() && stack != 0 );
 
   result = structure.mid( start, pos - start );
 
@@ -484,12 +485,12 @@ QByteArray FetchJobPrivate::parseString( const QByteArray &structure, int &pos )
     pos++;
     Q_FOREVER {
       if ( structure[pos] == '\\' ) {
-        pos+= 2;
+        pos += 2;
         foundSlash = true;
         continue;
       }
       if ( structure[pos] == '"' ) {
-        result = structure.mid( start+1, pos - start - 1);
+        result = structure.mid( start + 1, pos - start - 1 );
         pos++;
         break;
       }
@@ -497,27 +498,38 @@ QByteArray FetchJobPrivate::parseString( const QByteArray &structure, int &pos )
     }
   } else { // unquoted string
     Q_FOREVER {
-      if ( structure[pos] == ' ' || structure[pos] == '(' || structure[pos] == ')' || structure[pos] == '[' || structure[pos] == ']' || structure[pos] == '\n' || structure[pos] == '\r' || structure[pos] == '"') {
+      if ( structure[pos] == ' ' ||
+           structure[pos] == '(' ||
+           structure[pos] == ')' ||
+           structure[pos] == '[' ||
+           structure[pos] == ']' ||
+           structure[pos] == '\n' ||
+           structure[pos] == '\r' ||
+           structure[pos] == '"' ) {
         break;
       }
-      if (structure[pos] == '\\')
+      if ( structure[pos] == '\\' ) {
         foundSlash = true;
+      }
       pos++;
     }
 
     result = structure.mid( start, pos - start );
 
     // transform unquoted NIL
-    if ( result == "NIL" )
+    if ( result == "NIL" ) {
       result.clear();
+    }
   }
 
   // simplify slashes
   if ( foundSlash ) {
-    while ( result.contains( "\\\"" ) )
+    while ( result.contains( "\\\"" ) ) {
       result.replace( "\\\"", "\"" );
-    while ( result.contains( "\\\\" ) )
+    }
+    while ( result.contains( "\\\\" ) ) {
       result.replace( "\\\\", "\\" );
+    }
   }
 
   return result;
@@ -525,7 +537,10 @@ QByteArray FetchJobPrivate::parseString( const QByteArray &structure, int &pos )
 
 void FetchJobPrivate::skipLeadingSpaces( const QByteArray &structure, int &pos )
 {
-  while ( structure[pos]==' ' && pos<structure.size() ) pos++;
+  while ( pos < structure.size() && structure[pos] == ' '  ) {
+    pos++;
+  }
 }
 
 #include "fetchjob.moc"
+
diff --git a/kimap/fetchjob.h b/kimap/fetchjob.h
index aa31d2d..75fe6b6 100644
--- a/kimap/fetchjob.h
+++ b/kimap/fetchjob.h
@@ -56,7 +56,7 @@ typedef QList<QByteArray> MessageFlags;
 class KIMAP_EXPORT FetchJob : public Job
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(FetchJob)
+  Q_DECLARE_PRIVATE( FetchJob )
 
   friend class SessionPrivate;
 
diff --git a/kimap/getacljob.cpp b/kimap/getacljob.cpp
index fbe8d80..b218776 100644
--- a/kimap/getacljob.cpp
+++ b/kimap/getacljob.cpp
@@ -19,8 +19,8 @@
 
 #include "getacljob.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 
 #include "acljobbase_p.h"
 #include "message_p.h"
@@ -32,7 +32,7 @@ namespace KIMAP
   class GetAclJobPrivate : public AclJobBasePrivate
   {
     public:
-      GetAclJobPrivate( Session *session, const QString& name ) : AclJobBasePrivate(session, name) {}
+      GetAclJobPrivate( Session *session, const QString& name ) : AclJobBasePrivate( session, name ) {}
       ~GetAclJobPrivate() { }
 
       QMap<QByteArray, Acl::Rights> userRights;
@@ -42,7 +42,7 @@ namespace KIMAP
 using namespace KIMAP;
 
 GetAclJob::GetAclJob( Session *session )
-  : AclJobBase(  *new GetAclJobPrivate(session, i18n("GetAcl")  ))
+  : AclJobBase( *new GetAclJobPrivate( session, i18n( "GetAcl" ) ) )
 {
 }
 
@@ -52,24 +52,24 @@ GetAclJob::~GetAclJob()
 
 void GetAclJob::doStart()
 {
-  Q_D(GetAclJob);
+  Q_D( GetAclJob );
 
-  d->tags << d->sessionInternal()->sendCommand( "GETACL", '\"' + KIMAP::encodeImapFolderName( d->mailBox.toUtf8() ) + '\"');
+  d->tags << d->sessionInternal()->sendCommand( "GETACL", '\"' + KIMAP::encodeImapFolderName( d->mailBox.toUtf8() ) + '\"' );
 }
 
 void GetAclJob::handleResponse( const Message &response )
 {
-  Q_D(GetAclJob);
-//   qDebug() << response.toString();
+  Q_D( GetAclJob );
+//   kDebug() << response.toString();
 
-  if (handleErrorReplies(response) == NotHandled) {
-    if ( response.content.size() >= 4
-         && response.content[1].toString() == "ACL" ) {
+  if ( handleErrorReplies( response ) == NotHandled ) {
+    if ( response.content.size() >= 4 &&
+         response.content[1].toString() == "ACL" ) {
       int i = 3;
       while ( i < response.content.size() - 1 ) {
         QByteArray id = response.content[i].toString();
         QByteArray rights = response.content[i + 1].toString();
-        d->userRights[id] = Acl::rightsFromString(rights);
+        d->userRights[id] = Acl::rightsFromString( rights );
         i += 2;
       }
     }
@@ -78,15 +78,14 @@ void GetAclJob::handleResponse( const Message &response )
 
 QList<QByteArray> GetAclJob::identifiers() const
 {
-  Q_D(const GetAclJob);
+  Q_D( const GetAclJob );
   return d->userRights.keys();
 }
 
 bool GetAclJob::hasRightEnabled(const QByteArray &identifier, Acl::Right right) const
 {
-  Q_D(const GetAclJob);
-  if (d->userRights.contains(identifier))
-  {
+  Q_D( const GetAclJob );
+  if ( d->userRights.contains( identifier ) ) {
     Acl::Rights rights = d->userRights[identifier];
     return rights & right;
   }
@@ -96,10 +95,9 @@ bool GetAclJob::hasRightEnabled(const QByteArray &identifier, Acl::Right right)
 
 Acl::Rights GetAclJob::rights(const QByteArray &identifier) const
 {
-  Q_D(const GetAclJob);
+  Q_D( const GetAclJob );
   Acl::Rights result;
-  if (d->userRights.contains(identifier))
-  {
+  if ( d->userRights.contains( identifier ) ) {
     result = d->userRights[identifier];
   }
   return result;
@@ -107,8 +105,9 @@ Acl::Rights GetAclJob::rights(const QByteArray &identifier) const
 
 QMap<QByteArray, Acl::Rights> GetAclJob::allRights() const
 {
-  Q_D(const GetAclJob);
+  Q_D( const GetAclJob );
   return d->userRights;
 }
 
-#include "getacljob.moc"
\ No newline at end of file
+#include "getacljob.moc"
+
diff --git a/kimap/getacljob.h b/kimap/getacljob.h
index dd652d2..77a6648 100644
--- a/kimap/getacljob.h
+++ b/kimap/getacljob.h
@@ -30,7 +30,6 @@ class Session;
 struct Message;
 class GetAclJobPrivate;
 
-
 /**
  * Gets the ACL for a mailbox
  *
@@ -63,7 +62,7 @@ class GetAclJobPrivate;
 class KIMAP_EXPORT GetAclJob : public AclJobBase
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(GetAclJob)
+  Q_DECLARE_PRIVATE( GetAclJob )
 
   friend class SessionPrivate;
 
diff --git a/kimap/getmetadatajob.cpp b/kimap/getmetadatajob.cpp
index 69be41d..4dddce3 100644
--- a/kimap/getmetadatajob.cpp
+++ b/kimap/getmetadatajob.cpp
@@ -19,8 +19,8 @@
 
 #include "getmetadatajob.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 
 #include "metadatajobbase_p.h"
 #include "message_p.h"
@@ -32,7 +32,7 @@ namespace KIMAP
   class GetMetaDataJobPrivate : public MetaDataJobBasePrivate
   {
     public:
-      GetMetaDataJobPrivate( Session *session, const QString& name ) : MetaDataJobBasePrivate(session, name), maxSize(-1), depth("0") { }
+      GetMetaDataJobPrivate( Session *session, const QString& name ) : MetaDataJobBasePrivate( session, name ), maxSize( -1 ), depth( "0" ) { }
       ~GetMetaDataJobPrivate() { }
 
        qint64 maxSize;
@@ -47,7 +47,7 @@ namespace KIMAP
 using namespace KIMAP;
 
 GetMetaDataJob::GetMetaDataJob( Session *session )
-  : MetaDataJobBase( *new GetMetaDataJobPrivate(session, i18n("GetMetaData")) )
+  : MetaDataJobBase( *new GetMetaDataJobPrivate( session, i18n( "GetMetaData" ) ) )
 {
 }
 
@@ -57,94 +57,100 @@ GetMetaDataJob::~GetMetaDataJob()
 
 void GetMetaDataJob::doStart()
 {
-  Q_D(GetMetaDataJob);
+  Q_D( GetMetaDataJob );
   QByteArray parameters;
   parameters = '\"' + KIMAP::encodeImapFolderName( d->mailBox.toUtf8() ) + "\" ";
 
   QByteArray command = "GETMETADATA";
-  if (d->serverCapability == Annotatemore) {
-    d->m_name = i18n("GetAnnotation");
+  if ( d->serverCapability == Annotatemore ) {
+    d->m_name = i18n( "GetAnnotation" );
     command = "GETANNOTATION";
-    if (d->entries.size() > 1)
+    if ( d->entries.size() > 1 ) {
       parameters += '(';
-    Q_FOREACH(const QByteArray &entry, d->entries) {
+    }
+    Q_FOREACH ( const QByteArray &entry, d->entries ) {
       parameters += '\"' + entry + "\" ";
     }
-    if (d->entries.size() > 1)
-      parameters[parameters.length() -1 ] = ')';
-    else
-      parameters.truncate(parameters.length() -1);
+    if ( d->entries.size() > 1 ) {
+      parameters[parameters.length() - 1 ] = ')';
+    } else {
+      parameters.truncate( parameters.length() - 1 );
+    }
 
     parameters += ' ';
 
-    if (d->attributes.size() > 1)
+    if ( d->attributes.size() > 1 ) {
       parameters += '(';
-    Q_FOREACH(const QByteArray &attribute, d->attributes) {
+    }
+    Q_FOREACH ( const QByteArray &attribute, d->attributes ) {
       parameters += '\"' + attribute + "\" ";
     }
-    if (d->attributes.size() > 1)
-      parameters[parameters.length() -1 ] = ')';
-    else
-      parameters.truncate(parameters.length() -1);
+    if ( d->attributes.size() > 1 ) {
+      parameters[parameters.length() - 1 ] = ')';
+    } else {
+      parameters.truncate( parameters.length() - 1 );
+    }
 
   } else {
-    if (d->depth != "0") {
+    if ( d->depth != "0" ) {
       parameters += "(DEPTH " + d->depth;
     }
-    if (d->maxSize != -1) {
-      parameters += "(MAXSIZE " + QByteArray::number(d->maxSize) + ')';
+    if ( d->maxSize != -1 ) {
+      parameters += "(MAXSIZE " + QByteArray::number( d->maxSize ) + ')';
     }
-    if (d->depth != "0") {
+    if ( d->depth != "0" ) {
       parameters += " )";
     }
 
-    if (d->entries.size() > 1)
+    if ( d->entries.size() > 1 ) {
       parameters += '(';
-    Q_FOREACH(const QByteArray &entry, d->entries) {
+    }
+    Q_FOREACH ( const QByteArray &entry, d->entries ) {
       parameters += '\"' + entry + "\" ";
     }
-    if (d->entries.size() > 1)
-      parameters[parameters.length() -1 ] = ')';
+    if ( d->entries.size() > 1 ) {
+      parameters[parameters.length() - 1 ] = ')';
+    }
   }
 
-  if (d->entries.isEmpty()) {
+  if ( d->entries.isEmpty() ) { {
     parameters += ')';
   }
+  }
 
   d->tags << d->sessionInternal()->sendCommand( command, parameters );
-//  qDebug() << "SENT: " << command << " " << parameters;
+//  kDebug() << "SENT: " << command << " " << parameters;
 }
 
 void GetMetaDataJob::handleResponse( const Message &response )
 {
-  Q_D(GetMetaDataJob);
-//  qDebug() << "GOT: " << response.toString();
+  Q_D( GetMetaDataJob );
+//  kDebug() << "GOT: " << response.toString();
 
   //TODO: handle NO error messages having [METADATA MAXSIZE NNN], [METADATA TOOMANY], [METADATA NOPRIVATE] (see rfc5464)
   // or [ANNOTATEMORE TOOBIG], [ANNOTATEMORE TOOMANY] respectively
-  if (handleErrorReplies(response) == NotHandled ) {
+  if ( handleErrorReplies( response ) == NotHandled  ) {
     if ( response.content.size() >= 4 ) {
-      if (d->serverCapability == Annotatemore && response.content[1].toString() == "ANNOTATION" ) {
+      if ( d->serverCapability == Annotatemore && response.content[1].toString() == "ANNOTATION" ) {
         QString mailBox = QString::fromUtf8( KIMAP::decodeImapFolderName( response.content[2].toString() ) );
 
         int i = 3;
-        while (i < response.content.size() - 1) {
+        while ( i < response.content.size() - 1 ) {
           QByteArray entry = response.content[i].toString();
           QList<QByteArray> attributes = response.content[i + 1].toList();
           int j = 0;
-          while ( j < attributes.size() - 1) {
+          while ( j < attributes.size() - 1 ) {
             d->metadata[mailBox][entry][attributes[j]] = attributes[j + 1];
             j += 2;
           }
           i += 2;
         }
-      } else
-      if (d->serverCapability == Metadata && response.content[1].toString() == "METADATA" ) {
+      } else if ( d->serverCapability == Metadata && response.content[1].toString() == "METADATA" ) {
         QString mailBox = QString::fromUtf8( KIMAP::decodeImapFolderName( response.content[2].toString() ) );
 
         QList<QByteArray> entries = response.content[3].toList();
         int i = 0;
-        while ( i < entries.size() - 1) {
+        while ( i < entries.size() - 1 ) {
           d->metadata[mailBox][entries[i]][""] = entries[i + 1];
           i += 2;
         }
@@ -155,25 +161,25 @@ void GetMetaDataJob::handleResponse( const Message &response )
 
 void GetMetaDataJob::addEntry(const QByteArray &entry, const QByteArray &attribute)
 {
-  Q_D(GetMetaDataJob);
-  if (d->serverCapability == Annotatemore && attribute.isNull())
+  Q_D( GetMetaDataJob );
+  if ( d->serverCapability == Annotatemore && attribute.isNull() ) {
     qWarning() << "In ANNOTATEMORE mode an attribute must be specified with addEntry!";
-  d->entries.append(entry);
-  d->attributes.append(attribute);
+  }
+  d->entries.append( entry );
+  d->attributes.append( attribute );
 }
 
 void GetMetaDataJob::setMaximumSize(qint64 size)
 {
-  Q_D(GetMetaDataJob);
+  Q_D( GetMetaDataJob );
   d->maxSize = size;
 }
 
 void GetMetaDataJob::setDepth(Depth depth)
 {
-  Q_D(GetMetaDataJob);
+  Q_D( GetMetaDataJob );
 
-  switch (depth)
-  {
+  switch ( depth ) {
     case OneLevel:
       d->depth = "1"; //krazy:exclude=doublequote_chars
       break;
@@ -187,26 +193,27 @@ void GetMetaDataJob::setDepth(Depth depth)
 
 QByteArray GetMetaDataJob::metaData(const QString &mailBox, const QByteArray &entry, const QByteArray &attribute) const
 {
-  Q_D(const GetMetaDataJob);
+  Q_D( const GetMetaDataJob );
   QByteArray attr = attribute;
 
-  if (d->serverCapability == Metadata)
+  if ( d->serverCapability == Metadata ) {
      attr = "";
+  }
 
   QByteArray result;
-  if (d->metadata.contains(mailBox)) {
-    if (d->metadata[mailBox].contains(entry)) {
-      result = d->metadata[mailBox][entry].value(attr);
+  if ( d->metadata.contains( mailBox ) ) {
+    if ( d->metadata[mailBox].contains( entry ) ) {
+      result = d->metadata[mailBox][entry].value( attr );
     }
   }
-
   return result;
 }
 
 QMap<QByteArray, QMap<QByteArray, QByteArray> > GetMetaDataJob::allMetaData(const QString &mailBox) const
 {
-  Q_D(const GetMetaDataJob);
+  Q_D( const GetMetaDataJob );
   return d->metadata[mailBox];
 }
 
-#include "getmetadatajob.moc"
\ No newline at end of file
+#include "getmetadatajob.moc"
+
diff --git a/kimap/getquotajob.cpp b/kimap/getquotajob.cpp
index 9d1efb0..35d901e 100644
--- a/kimap/getquotajob.cpp
+++ b/kimap/getquotajob.cpp
@@ -19,8 +19,8 @@
 
 #include "getquotajob.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 
 #include "quotajobbase_p.h"
 #include "message_p.h"
@@ -31,7 +31,7 @@ namespace KIMAP
   class GetQuotaJobPrivate : public QuotaJobBasePrivate
   {
     public:
-      GetQuotaJobPrivate( Session *session, const QString& name ) : QuotaJobBasePrivate(session, name) { }
+      GetQuotaJobPrivate( Session *session, const QString& name ) : QuotaJobBasePrivate( session, name ) { }
       ~GetQuotaJobPrivate() { }
 
       QByteArray root;
@@ -41,7 +41,7 @@ namespace KIMAP
 using namespace KIMAP;
 
 GetQuotaJob::GetQuotaJob( Session *session )
-  : QuotaJobBase( *new GetQuotaJobPrivate(session, i18n("GetQuota")) )
+  : QuotaJobBase( *new GetQuotaJobPrivate( session, i18n( "GetQuota" ) ) )
 {
 }
 
@@ -51,34 +51,33 @@ GetQuotaJob::~GetQuotaJob()
 
 void GetQuotaJob::doStart()
 {
-  Q_D(GetQuotaJob);
+  Q_D( GetQuotaJob );
   //XXX: [alexmerry, 2010-07-24]: should d->root be quoted properly?
-  d->tags << d->sessionInternal()->sendCommand( "GETQUOTA", '\"' + d->root + '\"');
+  d->tags << d->sessionInternal()->sendCommand( "GETQUOTA", '\"' + d->root + '\"' );
 }
 
 void GetQuotaJob::handleResponse(const Message &response)
 {
-  Q_D(GetQuotaJob);
-  if (handleErrorReplies(response) == NotHandled) {
-    if ( response.content.size() >= 4
-         && response.content[1].toString() == "QUOTA" ) {
-      d->quota = d->readQuota(response.content[3]);
+  Q_D( GetQuotaJob );
+  if ( handleErrorReplies( response ) == NotHandled ) {
+    if ( response.content.size() >= 4 &&
+         response.content[1].toString() == "QUOTA" ) {
+      d->quota = d->readQuota( response.content[3] );
     }
   }
 }
 
 void GetQuotaJob::setRoot(const QByteArray& root)
 {
-  Q_D(GetQuotaJob);
-
+  Q_D( GetQuotaJob );
   d->root = root;
 }
 
 QByteArray GetQuotaJob::root() const
 {
-  Q_D(const GetQuotaJob);
-
+  Q_D( const GetQuotaJob );
   return d->root;
 }
 
-#include "getquotajob.moc"
\ No newline at end of file
+#include "getquotajob.moc"
+
diff --git a/kimap/getquotajob.h b/kimap/getquotajob.h
index 01231ea..698450a 100644
--- a/kimap/getquotajob.h
+++ b/kimap/getquotajob.h
@@ -50,7 +50,7 @@ class GetQuotaJobPrivate;
 class KIMAP_EXPORT GetQuotaJob : public QuotaJobBase
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(GetQuotaJob)
+  Q_DECLARE_PRIVATE( GetQuotaJob )
 
   friend class SessionPrivate;
 
@@ -60,7 +60,7 @@ class KIMAP_EXPORT GetQuotaJob : public QuotaJobBase
 
     /**
      * Set the quota root to get the resource limits for.
-     *
+     * @param root the quota root to set
      * @see GetQuotaRootJob
      */
     void setRoot(const QByteArray &root);
diff --git a/kimap/getquotarootjob.cpp b/kimap/getquotarootjob.cpp
index ee438a3..49e7bef 100644
--- a/kimap/getquotarootjob.cpp
+++ b/kimap/getquotarootjob.cpp
@@ -19,8 +19,8 @@
 
 #include "getquotarootjob.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 
 #include "quotajobbase_p.h"
 #include "message_p.h"
@@ -32,7 +32,7 @@ namespace KIMAP
   class GetQuotaRootJobPrivate : public QuotaJobBasePrivate
   {
     public:
-      GetQuotaRootJobPrivate( Session *session, const QString& name ) : QuotaJobBasePrivate(session, name) { }
+      GetQuotaRootJobPrivate( Session *session, const QString& name ) : QuotaJobBasePrivate( session, name ) { }
       ~GetQuotaRootJobPrivate() { }
 
       QString mailBox;
@@ -44,7 +44,7 @@ namespace KIMAP
 using namespace KIMAP;
 
 GetQuotaRootJob::GetQuotaRootJob( Session *session )
-  : QuotaJobBase( *new GetQuotaRootJobPrivate(session, i18n("GetQuotaRoot")) )
+  : QuotaJobBase( *new GetQuotaRootJobPrivate( session, i18n( "GetQuotaRoot" ) ) )
 {
 }
 
@@ -54,43 +54,41 @@ GetQuotaRootJob::~GetQuotaRootJob()
 
 void GetQuotaRootJob::doStart()
 {
-  Q_D(GetQuotaRootJob);
-  d->tags << d->sessionInternal()->sendCommand( "GETQUOTAROOT", '\"' + KIMAP::encodeImapFolderName( d->mailBox.toUtf8() ) + '\"');
+  Q_D( GetQuotaRootJob );
+  d->tags << d->sessionInternal()->sendCommand( "GETQUOTAROOT", '\"' + KIMAP::encodeImapFolderName( d->mailBox.toUtf8() ) + '\"' );
 }
 
 void GetQuotaRootJob::handleResponse(const Message &response)
 {
-  Q_D(GetQuotaRootJob);
-  if (handleErrorReplies(response) == NotHandled) {
+  Q_D( GetQuotaRootJob );
+  if ( handleErrorReplies( response ) == NotHandled ) {
     if ( response.content.size() >= 3 ) {
-      if (response.content[1].toString() == "QUOTAROOT" ) {
+      if ( response.content[1].toString() == "QUOTAROOT"  ) {
         d->rootList.clear();
         //some impls don't give the root a name which for us seems as if
         //there were no message part
         if ( response.content.size() == 3 ) {
-          d->rootList.append("");
+          d->rootList.append( "" );
         } else {
           int i = 3;
-          while ( i < response.content.size())
-          {
-            d->rootList.append(response.content[i].toString());
+          while ( i < response.content.size() ) {
+            d->rootList.append( response.content[i].toString() );
             i++;
           }
         }
-      } else
-      if (response.content[1].toString() == "QUOTA" ) {
+      } else if ( response.content[1].toString() == "QUOTA"  ) {
         QByteArray rootName;
         int  quotaContentIndex = 3;
         //some impls don't give the root a name in the response
-        if (response.content.size() == 3 ) {
+        if ( response.content.size() == 3  ) {
           quotaContentIndex = 2;
         } else {
           rootName = response.content[2].toString();
-        }       
+        }
 
         const QMap<QByteArray, QPair<qint64, qint64> >& quota = d->readQuota(response.content[quotaContentIndex]);
-        if (d->quotas.contains(rootName)) {
-          d->quotas[ rootName ].unite(quota);
+        if ( d->quotas.contains( rootName ) ) {
+          d->quotas[ rootName ].unite( quota );
         } else {
           d->quotas[ rootName ] = quota;
         }
@@ -99,61 +97,54 @@ void GetQuotaRootJob::handleResponse(const Message &response)
   }
 }
 
-
 void GetQuotaRootJob::setMailBox(const QString& mailBox)
 {
-  Q_D(GetQuotaRootJob);
-
+  Q_D( GetQuotaRootJob );
   d->mailBox = mailBox;
 }
 
 QString GetQuotaRootJob::mailBox() const
 {
-  Q_D(const GetQuotaRootJob);
-
+  Q_D( const GetQuotaRootJob );
   return d->mailBox;
 }
 
 QList<QByteArray> GetQuotaRootJob::roots() const
 {
-  Q_D(const GetQuotaRootJob);
-
+  Q_D( const GetQuotaRootJob );
   return d->rootList;
 }
 
 qint64 GetQuotaRootJob::usage(const QByteArray &root, const QByteArray &resource) const
 {
-  Q_D(const GetQuotaRootJob);
-
+  Q_D( const GetQuotaRootJob );
   QByteArray r = resource.toUpper();
 
-  if (d->quotas.contains(root) && d->quotas[root].contains(r)) {
+  if ( d->quotas.contains( root ) && d->quotas[root].contains( r ) ) {
     return d->quotas[root][r].first;
   }
-
   return -1;
 }
 
 qint64 GetQuotaRootJob::limit(const QByteArray &root, const QByteArray &resource) const
 {
-  Q_D(const GetQuotaRootJob);
+  Q_D( const GetQuotaRootJob );
 
   QByteArray r = resource.toUpper();
 
-  if (d->quotas.contains(root) && d->quotas[root].contains(r)) {
+  if ( d->quotas.contains( root ) && d->quotas[root].contains( r ) ) {
     return d->quotas[root][r].second;
   }
-
   return -1;
 }
 
 QMap<QByteArray, qint64> GetQuotaRootJob::allUsages(const QByteArray &root) const
 {
-  Q_D(const GetQuotaRootJob);
+  Q_D( const GetQuotaRootJob );
 
   QMap<QByteArray, qint64> result;
 
-  if (d->quotas.contains(root)) {
+  if ( d->quotas.contains( root ) ) {
     const QMap< QByteArray, QPair<qint64, qint64> > quota = d->quotas[root];
     QMapIterator<QByteArray, QPair<qint64, qint64> > it( quota );
     while ( it.hasNext() ) {
@@ -161,17 +152,16 @@ QMap<QByteArray, qint64> GetQuotaRootJob::allUsages(const QByteArray &root) cons
       result[it.key()] = it.value().first;
     }
   }
-
   return result;
 }
 
 QMap<QByteArray, qint64> GetQuotaRootJob::allLimits(const QByteArray &root) const
 {
-  Q_D(const GetQuotaRootJob);
+  Q_D( const GetQuotaRootJob );
 
   QMap<QByteArray, qint64> result;
 
-  if (d->quotas.contains(root)) {
+  if ( d->quotas.contains( root ) ) {
     const QMap< QByteArray, QPair<qint64, qint64> > quota = d->quotas[root];
     QMapIterator<QByteArray, QPair<qint64, qint64> > it( quota );
     while ( it.hasNext() ) {
@@ -179,8 +169,8 @@ QMap<QByteArray, qint64> GetQuotaRootJob::allLimits(const QByteArray &root) cons
       result[it.key()] = it.value().second;
     }
   }
-
   return result;
 }
 
 #include "getquotarootjob.moc"
+
diff --git a/kimap/getquotarootjob.h b/kimap/getquotarootjob.h
index b1fa49e..3541e18 100644
--- a/kimap/getquotarootjob.h
+++ b/kimap/getquotarootjob.h
@@ -50,7 +50,7 @@ class GetQuotaRootJobPrivate;
 class KIMAP_EXPORT GetQuotaRootJob : public QuotaJobBase
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(GetQuotaRootJob)
+  Q_DECLARE_PRIVATE( GetQuotaRootJob )
 
   friend class SessionPrivate;
 
diff --git a/kimap/idlejob.cpp b/kimap/idlejob.cpp
index 0248697..5f75429 100644
--- a/kimap/idlejob.cpp
+++ b/kimap/idlejob.cpp
@@ -20,7 +20,7 @@
 #include "idlejob.h"
 
 #include <QtCore/QTimer>
-#include <klocale.h>
+#include <KDE/KLocalizedString>
 
 #include "job_p.h"
 #include "message_p.h"
@@ -32,7 +32,7 @@ namespace KIMAP
   {
     public:
       IdleJobPrivate( IdleJob *job, Session *session, const QString& name )
-        : JobPrivate( session, name ), q(job),
+        : JobPrivate( session, name ), q( job ),
           messageCount( -1 ), recentCount( -1 ),
           lastMessageCount( -1 ), lastRecentCount( -1 ),
           originalSocketTimeout( -1 ) { }
@@ -42,8 +42,8 @@ namespace KIMAP
       {
         emitStatsTimer.stop();
 
-        emit q->mailBoxStats(q, m_session->selectedMailBox(),
-                             messageCount, recentCount);
+        emit q->mailBoxStats( q, m_session->selectedMailBox(),
+                              messageCount, recentCount );
 
         lastMessageCount = messageCount;
         lastRecentCount = recentCount;
@@ -69,9 +69,9 @@ namespace KIMAP
 using namespace KIMAP;
 
 IdleJob::IdleJob( Session *session )
-  : Job( *new IdleJobPrivate(this, session, i18nc("name of the idle job", "Idle")) )
+  : Job( *new IdleJobPrivate( this, session, i18nc( "name of the idle job", "Idle" ) ) )
 {
-  Q_D(IdleJob);
+  Q_D( IdleJob );
   connect( &d->emitStatsTimer, SIGNAL(timeout()),
            this, SLOT(emitStats()) );
 }
@@ -82,14 +82,14 @@ IdleJob::~IdleJob()
 
 void KIMAP::IdleJob::stop()
 {
-  Q_D(IdleJob);
+  Q_D( IdleJob );
   d->sessionInternal()->setSocketTimeout( d->originalSocketTimeout );
   d->sessionInternal()->sendData( "DONE" );
 }
 
 void IdleJob::doStart()
 {
-  Q_D(IdleJob);
+  Q_D( IdleJob );
   d->originalSocketTimeout = d->sessionInternal()->socketTimeout();
   d->sessionInternal()->setSocketTimeout( -1 );
   d->tags << d->sessionInternal()->sendCommand( "IDLE" );
@@ -97,33 +97,32 @@ void IdleJob::doStart()
 
 void IdleJob::handleResponse( const Message &response )
 {
-  Q_D(IdleJob);
+  Q_D( IdleJob );
 
   // We can predict it'll be handled by handleErrorReplies() so emit
   // pending signals now (if needed) so that result() will really be
   // the last emitted signal.
-  if ( !response.content.isEmpty()
-       && d->tags.size() == 1
-       && d->tags.contains( response.content.first().toString() )
-       && ( d->messageCount>=0 || d->recentCount>=0 ) ) {
+  if ( !response.content.isEmpty() &&
+       d->tags.size() == 1 &&
+       d->tags.contains( response.content.first().toString() ) &&
+       ( d->messageCount >= 0 || d->recentCount >= 0 ) ) {
     d->emitStats();
   }
 
-
-  if (handleErrorReplies(response) == NotHandled ) {
-    if ( response.content.size() > 0 && response.content[0].toString()=="+" ) {
+  if ( handleErrorReplies( response ) == NotHandled  ) {
+    if ( response.content.size() > 0 && response.content[0].toString() == "+" ) {
       // Got the continuation all is fine
       return;
 
     } else if ( response.content.size() > 2 ) {
-        if ( response.content[2].toString()=="EXISTS" ) {
-        if ( d->messageCount>=0 ) {
+        if ( response.content[2].toString() == "EXISTS" ) {
+        if ( d->messageCount >= 0 ) {
           d->emitStats();
         }
 
         d->messageCount = response.content[1].toString().toInt();
-      } else if ( response.content[2].toString()=="RECENT" ) {
-        if ( d->recentCount>=0 ) {
+      } else if ( response.content[2].toString() == "RECENT" ) {
+        if ( d->recentCount >= 0 ) {
           d->emitStats();
         }
 
@@ -141,20 +140,21 @@ void IdleJob::handleResponse( const Message &response )
 
 QString KIMAP::IdleJob::lastMailBox() const
 {
-  Q_D(const IdleJob);
+  Q_D( const IdleJob );
   return d->m_session->selectedMailBox();
 }
 
 int KIMAP::IdleJob::lastMessageCount() const
 {
-  Q_D(const IdleJob);
+  Q_D( const IdleJob );
   return d->lastMessageCount;
 }
 
 int KIMAP::IdleJob::lastRecentCount() const
 {
-  Q_D(const IdleJob);
+  Q_D( const IdleJob );
   return d->lastRecentCount;
 }
 
 #include "idlejob.moc"
+
diff --git a/kimap/idlejob.h b/kimap/idlejob.h
index 3a0917b..784155a 100644
--- a/kimap/idlejob.h
+++ b/kimap/idlejob.h
@@ -63,7 +63,7 @@ class IdleJobPrivate;
 class KIMAP_EXPORT IdleJob : public Job
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(IdleJob)
+  Q_DECLARE_PRIVATE( IdleJob )
 
   public:
     explicit IdleJob( Session *session );
diff --git a/kimap/imapset.cpp b/kimap/imapset.cpp
index 8588452..6c4e9ea 100644
--- a/kimap/imapset.cpp
+++ b/kimap/imapset.cpp
@@ -56,7 +56,6 @@ class ImapSet::Private : public QSharedData
     ImapInterval::List intervals;
 };
 
-
 ImapInterval::ImapInterval() :
     d( new Private )
 {
@@ -80,8 +79,9 @@ ImapInterval::~ ImapInterval()
 
 ImapInterval& ImapInterval::operator =(const ImapInterval & other)
 {
-  if ( this != & other )
+  if ( this != &other ) {
     d = other.d;
+  }
   return *this;
 }
 
@@ -92,10 +92,12 @@ bool ImapInterval::operator ==(const ImapInterval & other) const
 
 ImapInterval::Id ImapInterval::size() const
 {
-  if ( !d->begin && !d->end )
+  if ( !d->begin && !d->end ) {
     return 0;
-  if ( d->begin && !d->end )
+  }
+  if ( d->begin && !d->end ) {
     return Q_INT64_C( 0x7FFFFFFFFFFFFFFF ) - d->begin + 1;
+  }
   return d->end - d->begin + 1;
 }
 
@@ -116,8 +118,9 @@ bool ImapInterval::hasDefinedEnd() const
 
 ImapInterval::Id ImapInterval::end() const
 {
-  if ( hasDefinedEnd() )
+  if ( hasDefinedEnd() ) {
     return d->end;
+  }
   return 0xFFFFFFFF; // should be INT_MAX, but where is that defined again?
 }
 
@@ -137,16 +140,19 @@ void ImapInterval::setEnd(Id value)
 
 QByteArray ImapInterval::toImapSequence() const
 {
-  if ( size() == 0 )
+  if ( size() == 0 ) {
     return QByteArray();
-  if ( size() == 1 )
+  }
+  if ( size() == 1 ) {
     return QByteArray::number( d->begin );
+  }
   QByteArray rv;
   rv += QByteArray::number( d->begin ) + ':';
-  if ( hasDefinedEnd() )
+  if ( hasDefinedEnd() ) {
     rv += QByteArray::number( d->end );
-  else
+  } else {
     rv += '*';
+  }
   return rv;
 }
 
@@ -158,7 +164,7 @@ ImapInterval ImapInterval::fromImapSequence( const QByteArray &sequence )
   }
 
   bool ok = false;
-  Id begin = values[0].toLongLong(&ok);
+  Id begin = values[0].toLongLong( &ok );
 
   if ( !ok ) {
     return ImapInterval();
@@ -172,7 +178,7 @@ ImapInterval ImapInterval::fromImapSequence( const QByteArray &sequence )
     end = 0;
   } else {
     ok = false;
-    end = values[1].toLongLong(&ok);
+    end = values[1].toLongLong( &ok );
     if ( !ok ) {
       return ImapInterval();
     }
@@ -209,8 +215,9 @@ ImapSet::~ImapSet()
 
 ImapSet & ImapSet::operator =(const ImapSet & other)
 {
-  if ( this != &other )
+  if ( this != &other ) {
     d = other.d;
+  }
   return *this;
 }
 
@@ -238,7 +245,7 @@ void ImapSet::add(const QList<Id> & values)
 {
   QList<Id> vals = values;
   qSort( vals );
-  for( int i = 0; i < vals.count(); ++i ) {
+  for ( int i = 0; i < vals.count(); ++i ) {
     const int begin = vals[i];
     Q_ASSERT( begin >= 0 );
     if ( i == vals.count() - 1 ) {
@@ -248,7 +255,7 @@ void ImapSet::add(const QList<Id> & values)
     do {
       ++i;
       Q_ASSERT( vals[i] >= 0 );
-      if ( vals[i] != (vals[i - 1] + 1) ) {
+      if ( vals[i] != ( vals[i - 1] + 1 ) ) {
         --i;
         break;
       }
@@ -276,7 +283,7 @@ QByteArray ImapSet::toImapSequenceSet() const
     QList<QByteArray>::ConstIterator it = rv.constBegin();
     ++it;
     for ( ; it != rv.constEnd(); ++it ) {
-      result += ',' + (*it);
+      result += ',' + ( *it );
     }
   }
 
@@ -289,7 +296,7 @@ ImapSet ImapSet::fromImapSequenceSet( const QByteArray &sequence )
 
   QList<QByteArray> intervals = sequence.split( ',' );
 
-  foreach( const QByteArray &interval, intervals ) {
+  foreach ( const QByteArray &interval, intervals ) {
     if ( !interval.isEmpty() ) {
       result.add( ImapInterval::fromImapSequence( interval ) );
     }
@@ -319,4 +326,3 @@ QDebug& operator<<( QDebug &d, const ImapSet &set )
   d << set.toImapSequenceSet();
   return d;
 }
-
diff --git a/kimap/imapset.h b/kimap/imapset.h
index a3417ac..a217251 100644
--- a/kimap/imapset.h
+++ b/kimap/imapset.h
@@ -199,6 +199,7 @@ class KIMAP_EXPORT ImapSet
     /**
       Adds the given ImapInterval to this set.
       No interval merging is performed.
+      @param interval the interval to add
     */
     void add( const ImapInterval &interval );
 
diff --git a/kimap/imapstreamparser.cpp b/kimap/imapstreamparser.cpp
index 50a8552..37bf691 100644
--- a/kimap/imapstreamparser.cpp
+++ b/kimap/imapstreamparser.cpp
@@ -48,20 +48,21 @@ QString ImapStreamParser::readUtf8String()
   return result;
 }
 
-
 QByteArray ImapStreamParser::readString()
 {
   QByteArray result;
-  if ( !waitForMoreData( m_data.length() == 0 ) )
-    throw ImapParserException("Unable to read more data");
+  if ( !waitForMoreData( m_data.length() == 0 ) ) {
+    throw ImapParserException( "Unable to read more data" );
+  }
   stripLeadingSpaces();
-  if ( !waitForMoreData( m_position >= m_data.length() ) )
-    throw ImapParserException("Unable to read more data");
+  if ( !waitForMoreData( m_position >= m_data.length() ) ) {
+    throw ImapParserException( "Unable to read more data" );
+  }
 
   // literal string
   // TODO: error handling
   if ( hasLiteral() ) {
-    while (!atLiteralEnd()) {
+    while ( !atLiteralEnd() ) {
       result += readLiteralPart();
     }
     return result;
@@ -73,58 +74,65 @@ QByteArray ImapStreamParser::readString()
 
 bool ImapStreamParser::hasString()
 {
-  if ( !waitForMoreData( m_position >= m_data.length() ) )
-    throw ImapParserException("Unable to read more data");
+  if ( !waitForMoreData( m_position >= m_data.length() ) ) {
+    throw ImapParserException( "Unable to read more data" );
+  }
   int savedPos = m_position;
   stripLeadingSpaces();
   int pos = m_position;
   m_position = savedPos;
-  if ( m_data.at(pos) == '{' )
+  if ( m_data.at( pos ) == '{' ) {
     return true; //literal string
-  if (m_data.at(pos) == '"' )
+  }
+  if ( m_data.at( pos ) == '"' ) {
     return true; //quoted string
-  if ( m_data.at(pos) != ' ' &&
-       m_data.at(pos) != '(' &&
-       m_data.at(pos) != ')' &&
-       m_data.at(pos) != '[' &&
-       m_data.at(pos) != ']' &&
-       m_data.at(pos) != '\n' &&
-       m_data.at(pos) != '\r' )
+  }
+  if ( m_data.at( pos ) != ' ' &&
+       m_data.at( pos ) != '(' &&
+       m_data.at( pos ) != ')' &&
+       m_data.at( pos ) != '[' &&
+       m_data.at( pos ) != ']' &&
+       m_data.at( pos ) != '\n' &&
+       m_data.at( pos ) != '\r' ) {
     return true;  //unquoted string
+  }
 
   return false; //something else, not a string
 }
 
 bool ImapStreamParser::hasLiteral()
 {
-  if ( !waitForMoreData( m_position >= m_data.length() ) )
-    throw ImapParserException("Unable to read more data");
+  if ( !waitForMoreData( m_position >= m_data.length() ) ) {
+    throw ImapParserException( "Unable to read more data" );
+  }
   int savedPos = m_position;
   stripLeadingSpaces();
-  if ( m_data.at(m_position) == '{' )
-  {
+  if ( m_data.at( m_position ) == '{' ) {
     int end = -1;
     do {
       end = m_data.indexOf( '}', m_position );
-      if ( !waitForMoreData( end == -1 ) )
-        throw ImapParserException("Unable to read more data");
-    } while (end == -1);
+      if ( !waitForMoreData( end == -1 ) ) {
+        throw ImapParserException( "Unable to read more data" );
+      }
+    } while ( end == -1 );
     Q_ASSERT( end > m_position );
     m_literalSize = m_data.mid( m_position + 1, end - m_position - 1 ).toInt();
     // strip CRLF
     m_position = end + 1;
 
-    if ( m_position < m_data.length() && m_data.at(m_position) == '\r' )
+    if ( m_position < m_data.length() && m_data.at( m_position ) == '\r' ) {
       ++m_position;
-    if ( m_position < m_data.length() && m_data.at(m_position) == '\n' )
+    }
+    if ( m_position < m_data.length() && m_data.at( m_position ) == '\n' ) {
       ++m_position;
+    }
 
     //FIXME: Makes sense only on the server side?
-    if (m_isServerModeEnabled && m_literalSize > 0)
+    if ( m_isServerModeEnabled && m_literalSize > 0 ) {
       sendContinuationResponse( m_literalSize );
+    }
     return true;
-  } else
-  {
+  } else {
     m_position = savedPos;
     return false;
   }
@@ -132,7 +140,7 @@ bool ImapStreamParser::hasLiteral()
 
 bool ImapStreamParser::atLiteralEnd() const
 {
-  return (m_literalSize == 0);
+  return ( m_literalSize == 0 );
 }
 
 QByteArray ImapStreamParser::readLiteralPart()
@@ -140,18 +148,19 @@ QByteArray ImapStreamParser::readLiteralPart()
   static qint64 maxLiteralPartSize = 4096;
   int size = qMin(maxLiteralPartSize, m_literalSize);
 
-  if ( !waitForMoreData( m_data.length() < m_position + size ) )
-    throw ImapParserException("Unable to read more data");
+  if ( !waitForMoreData( m_data.length() < m_position + size ) ) {
+    throw ImapParserException( "Unable to read more data" );
+  }
 
   if ( m_data.length() < m_position + size ) { // Still not enough data
     // Take what's already there
     size = m_data.length() - m_position;
   }
 
-  QByteArray result = m_data.mid(m_position, size);
+  QByteArray result = m_data.mid( m_position, size );
   m_position += size;
   m_literalSize -= size;
-  Q_ASSERT(m_literalSize >= 0);
+  Q_ASSERT( m_literalSize >= 0 );
   trimBuffer();
 
   return result;
@@ -159,80 +168,81 @@ QByteArray ImapStreamParser::readLiteralPart()
 
 bool ImapStreamParser::hasList()
 {
-  if ( !waitForMoreData( m_position >= m_data.length() ) )
-    throw ImapParserException("Unable to read more data");
+  if ( !waitForMoreData( m_position >= m_data.length() ) ) {
+    throw ImapParserException( "Unable to read more data" );
+  }
   int savedPos = m_position;
   stripLeadingSpaces();
   int pos = m_position;
   m_position = savedPos;
-  if ( m_data.at(pos) == '(' )
-  {
+  if ( m_data.at( pos ) == '(' ) {
     return true;
   }
-
   return false;
 }
 
 bool ImapStreamParser::atListEnd()
 {
-  if ( !waitForMoreData( m_position >= m_data.length() ) )
-    throw ImapParserException("Unable to read more data");
+  if ( !waitForMoreData( m_position >= m_data.length() ) ) {
+    throw ImapParserException( "Unable to read more data" );
+  }
   int savedPos = m_position;
   stripLeadingSpaces();
   int pos = m_position;
   m_position = savedPos;
-  if ( m_data.at(pos) == ')' )
-  {
+  if ( m_data.at( pos ) == ')' ) {
     m_position = pos + 1;
     return true;
   }
-
   return false;
 }
 
 QList<QByteArray> ImapStreamParser::readParenthesizedList()
 {
   QList<QByteArray> result;
-  if (! waitForMoreData( m_data.length() <= m_position ) )
-    throw ImapParserException("Unable to read more data");
+  if ( !waitForMoreData( m_data.length() <= m_position ) ) {
+    throw ImapParserException( "Unable to read more data" );
+  }
 
   stripLeadingSpaces();
-  if ( m_data.at(m_position) != '(' )
+  if ( m_data.at( m_position ) != '(' ) {
     return result; //no list found
+  }
 
   bool concatToLast = false;
   int count = 0;
   int sublistbegin = m_position;
   int i = m_position + 1;
   Q_FOREVER {
-    if ( !waitForMoreData( m_data.length() <= i ) )
-    {
+    if ( !waitForMoreData( m_data.length() <= i ) ) {
       m_position = i;
-      throw ImapParserException("Unable to read more data");
+      throw ImapParserException( "Unable to read more data" );
     }
-    if ( m_data.at(i) == '(' ) {
+    if ( m_data.at( i ) == '(' ) {
       ++count;
-      if ( count == 1 )
+      if ( count == 1 ) {
         sublistbegin = i;
+      }
       ++i;
       continue;
     }
-    if ( m_data.at(i) == ')' ) {
+    if ( m_data.at( i ) == ')' ) {
       if ( count <= 0 ) {
         m_position = i + 1;
         return result;
       }
-      if ( count == 1 )
+      if ( count == 1 ) {
         result.append( m_data.mid( sublistbegin, i - sublistbegin + 1 ) );
+      }
       --count;
       ++i;
       continue;
     }
-    if ( m_data.at(i) == ' ' ) {
+    if ( m_data.at( i ) == ' ' ) {
       ++i;
       continue;
     }
-    if ( m_data.at(i) == '"' ) {
+    if ( m_data.at( i ) == '"' ) {
       if ( count > 0 ) {
         m_position = i;
         parseQuotedString();
@@ -240,27 +250,27 @@ QList<QByteArray> ImapStreamParser::readParenthesizedList()
         continue;
       }
     }
-    if ( m_data.at(i) == '[' ) {
+    if ( m_data.at( i ) == '[' ) {
       concatToLast = true;
       if ( result.isEmpty() ) {
         result.append( QByteArray() );
       }
-      result.last()+='[';
+      result.last() += '[';
       ++i;
       continue;
     }
-    if ( m_data.at(i) == ']' ) {
+    if ( m_data.at( i ) == ']' ) {
       concatToLast = false;
-      result.last()+=']';
+      result.last() += ']';
       ++i;
       continue;
     }
     if ( count == 0 ) {
       m_position = i;
       QByteArray ba;
-      if (hasLiteral()) {
-        while (!atLiteralEnd()) {
-          ba+=readLiteralPart();
+      if ( hasLiteral() ) {
+        while ( !atLiteralEnd() ) {
+          ba += readLiteralPart();
         }
       } else {
         ba = readString();
@@ -268,13 +278,14 @@ QList<QByteArray> ImapStreamParser::readParenthesizedList()
 
       // We might sometime get some unwanted CRLF, but we're still not at the end
       // of the list, would make further string reads fail so eat the CRLFs.
-      while ( ( m_position < m_data.size() ) && ( m_data.at(m_position) == '\r' || m_data.at(m_position) == '\n' ) ) {
+      while ( ( m_position < m_data.size() ) &&
+              ( m_data.at( m_position ) == '\r' || m_data.at( m_position ) == '\n' ) ) {
         m_position++;
       }
 
       i = m_position - 1;
-      if (concatToLast) {
-        result.last()+=ba;
+      if ( concatToLast ) {
+        result.last() += ba;
       } else {
         result.append( ba );
       }
@@ -287,68 +298,68 @@ QList<QByteArray> ImapStreamParser::readParenthesizedList()
 
 bool ImapStreamParser::hasResponseCode()
 {
-  if ( !waitForMoreData( m_position >= m_data.length() ) )
-    throw ImapParserException("Unable to read more data");
+  if ( !waitForMoreData( m_position >= m_data.length() ) ) {
+    throw ImapParserException( "Unable to read more data" );
+  }
   int savedPos = m_position;
   stripLeadingSpaces();
   int pos = m_position;
   m_position = savedPos;
-  if ( m_data.at(pos) == '[' )
-  {
+  if ( m_data.at( pos ) == '[' ) {
     m_position = pos + 1;
     return true;
   }
-
   return false;
 }
 
 bool ImapStreamParser::atResponseCodeEnd()
 {
-  if ( !waitForMoreData( m_position >= m_data.length() ) )
-    throw ImapParserException("Unable to read more data");
+  if ( !waitForMoreData( m_position >= m_data.length() ) ) {
+    throw ImapParserException( "Unable to read more data" );
+  }
   int savedPos = m_position;
   stripLeadingSpaces();
   int pos = m_position;
   m_position = savedPos;
-  if ( m_data.at(pos) == ']' )
-  {
+  if ( m_data.at( pos ) == ']' ) {
     m_position = pos + 1;
     return true;
   }
-
   return false;
 }
 
 QByteArray ImapStreamParser::parseQuotedString()
 {
   QByteArray result;
-  if (! waitForMoreData( m_data.length() == 0 ) )
-    throw ImapParserException("Unable to read more data");
+  if ( !waitForMoreData( m_data.length() == 0 ) ) {
+    throw ImapParserException( "Unable to read more data" );
+  }
   stripLeadingSpaces();
   int end = m_position;
   result.clear();
-  if ( !waitForMoreData( m_position >= m_data.length() ) )
-    throw ImapParserException("Unable to read more data");
-  if ( !waitForMoreData( m_position >= m_data.length() ) )
-    throw ImapParserException("Unable to read more data");
+  if ( !waitForMoreData( m_position >= m_data.length() ) ) {
+    throw ImapParserException( "Unable to read more data" );
+  }
+  if ( !waitForMoreData( m_position >= m_data.length() ) ) {
+    throw ImapParserException( "Unable to read more data" );
+  }
 
   bool foundSlash = false;
   // quoted string
-  if ( m_data.at(m_position) == '"' ) {
+  if ( m_data.at( m_position ) == '"' ) {
     ++m_position;
     int i = m_position;
     Q_FOREVER {
-      if ( !waitForMoreData( m_data.length() <= i ) )
-      {
+      if ( !waitForMoreData( m_data.length() <= i ) ) {
         m_position = i;
-        throw ImapParserException("Unable to read more data");
+        throw ImapParserException( "Unable to read more data" );
       }
-      if ( m_data.at(i) == '\\' ) {
+      if ( m_data.at( i ) == '\\' ) {
         i += 2;
         foundSlash = true;
         continue;
       }
-      if ( m_data.at(i) == '"' ) {
+      if ( m_data.at( i ) == '"' ) {
         result = m_data.mid( m_position, i - m_position );
         end = i + 1; // skip the '"'
         break;
@@ -362,32 +373,42 @@ QByteArray ImapStreamParser::parseQuotedString()
     bool reachedInputEnd = true;
     int i = m_position;
     Q_FOREVER {
-      if ( !waitForMoreData( m_data.length() <= i ) )
-      {
+      if ( !waitForMoreData( m_data.length() <= i ) ) {
         m_position = i;
-        throw ImapParserException("Unable to read more data");
+        throw ImapParserException( "Unable to read more data" );
       }
-      if ( m_data.at(i) == ' ' || m_data.at(i) == '(' || m_data.at(i) == ')' || m_data.at(i) == '[' || m_data.at(i) == ']' || m_data.at(i) == '\n' || m_data.at(i) == '\r' || m_data.at(i) == '"') {
+      if ( m_data.at( i ) == ' ' ||
+           m_data.at( i ) == '(' ||
+           m_data.at( i ) == ')' ||
+           m_data.at( i ) == '[' ||
+           m_data.at( i ) == ']' ||
+           m_data.at( i ) == '\n' ||
+           m_data.at( i ) == '\r' ||
+           m_data.at( i ) == '"' ) {
         end = i;
         reachedInputEnd = false;
         break;
       }
-      if (m_data.at(i) == '\\')
+      if ( m_data.at( i ) == '\\' ) {
         foundSlash = true;
+      }
       i++;
     }
-    if ( reachedInputEnd ) //FIXME: how can it get here?
+    if ( reachedInputEnd ) { //FIXME: how can it get here?
       end = m_data.length();
+    }
 
     result = m_data.mid( m_position, end - m_position );
   }
 
   // strip quotes
   if ( foundSlash ) {
-    while ( result.contains( "\\\"" ) )
+    while ( result.contains( "\\\"" ) ) {
       result.replace( "\\\"", "\"" );
-    while ( result.contains( "\\\\" ) )
+    }
+    while ( result.contains( "\\\\" ) ) {
       result.replace( "\\\\", "\\" );
+    }
   }
   m_position = end;
   return result;
@@ -396,24 +417,28 @@ QByteArray ImapStreamParser::parseQuotedString()
 qint64 ImapStreamParser::readNumber( bool * ok )
 {
   qint64  result;
-  if ( ok )
+  if ( ok ) {
     *ok = false;
-  if (! waitForMoreData( m_data.length() == 0 ) )
-    throw ImapParserException("Unable to read more data");
+  }
+  if ( !waitForMoreData( m_data.length() == 0 ) ) {
+    throw ImapParserException( "Unable to read more data" );
+  }
   stripLeadingSpaces();
-  if ( !waitForMoreData( m_position >= m_data.length() ) )
-    throw ImapParserException("Unable to read more data");
-  if ( m_position >= m_data.length() )
-    throw ImapParserException("Unable to read more data");
+  if ( !waitForMoreData( m_position >= m_data.length() ) ) {
+    throw ImapParserException( "Unable to read more data" );
+  }
+  if ( m_position >= m_data.length() ) {
+    throw ImapParserException( "Unable to read more data" );
+  }
   int i = m_position;
   Q_FOREVER {
-    if ( !waitForMoreData( m_data.length() <= i ) )
-    {
+    if ( !waitForMoreData( m_data.length() <= i ) ) {
       m_position = i;
-      throw ImapParserException("Unable to read more data");
+      throw ImapParserException( "Unable to read more data" );
     }
-    if ( !isdigit( m_data.at( i ) ) )
+    if ( !isdigit( m_data.at( i ) ) ) {
       break;
+    }
     ++i;
   }
   const QByteArray tmp = m_data.mid( m_position, i - m_position );
@@ -425,8 +450,7 @@ qint64 ImapStreamParser::readNumber( bool * ok )
 void ImapStreamParser::stripLeadingSpaces()
 {
   for ( int i = m_position; i < m_data.length(); ++i ) {
-    if ( m_data.at(i) != ' ' )
-    {
+    if ( m_data.at( i ) != ' ' ) {
       m_position = i;
       return;
     }
@@ -438,10 +462,9 @@ bool ImapStreamParser::waitForMoreData( bool wait )
 {
    if ( wait ) {
      if ( m_socket->bytesAvailable() > 0 ||
-          m_socket->waitForReadyRead(30000) ) {
+          m_socket->waitForReadyRead( 30000 ) ) {
         m_data.append( m_socket->readAll() );
-     } else
-     {
+     } else {
        return false;
      }
    }
@@ -455,28 +478,31 @@ void ImapStreamParser::setData( const QByteArray &data )
 
 QByteArray ImapStreamParser::readRemainingData()
 {
-  return m_data.mid(m_position);
+  return m_data.mid( m_position );
 }
 
 int ImapStreamParser::availableDataSize() const
 {
-  return m_socket->bytesAvailable()+m_data.size()-m_position;
+  return m_socket->bytesAvailable() + m_data.size() - m_position;
 }
 
 bool ImapStreamParser::atCommandEnd()
 {
   int savedPos = m_position;
   do {
-    if ( !waitForMoreData( m_position >= m_data.length() ) )
-      throw ImapParserException("Unable to read more data");
+    if ( !waitForMoreData( m_position >= m_data.length() ) ) {
+      throw ImapParserException( "Unable to read more data" );
+    }
     stripLeadingSpaces();
   } while ( m_position >= m_data.size() );
 
-  if ( m_data.at(m_position) == '\n' || m_data.at(m_position) == '\r') {
-    if ( m_data.at(m_position) == '\r' )
+  if ( m_data.at( m_position ) == '\n' || m_data.at( m_position ) == '\r' ) {
+    if ( m_data.at( m_position ) == '\r' ) {
       ++m_position;
-    if ( m_position < m_data.length() && m_data.at(m_position) == '\n' )
+    }
+    if ( m_position < m_data.length() && m_data.at( m_position ) == '\n' ) {
       ++m_position;
+    }
 
     // We'd better empty m_data from time to time before it grows out of control
     trimBuffer();
@@ -493,29 +519,30 @@ QByteArray ImapStreamParser::readUntilCommandEnd()
   int i = m_position;
   int paranthesisBalance = 0;
   Q_FOREVER {
-    if ( !waitForMoreData( m_data.length() <= i ) )
-    {
+    if ( !waitForMoreData( m_data.length() <= i ) ) {
       m_position = i;
-      throw ImapParserException("Unable to read more data");
+      throw ImapParserException( "Unable to read more data" );
     }
-    if ( m_data.at(i) == '{' )
-    {
+    if ( m_data.at( i ) == '{' ) {
       m_position = i - 1;
       hasLiteral(); //init literal size
-      result.append(m_data.mid(i-1, m_position - i +1));
-      while (!atLiteralEnd())
-      {
+      result.append( m_data.mid( i - 1, m_position - i + 1 ) );
+      while ( !atLiteralEnd() ) {
         result.append( readLiteralPart() );
       }
       i = m_position;
     }
-    if ( m_data.at(i) == '(' )
+    if ( m_data.at( i ) == '(' ) {
       paranthesisBalance++;
-    if ( m_data.at(i) == ')' )
+    }
+    if ( m_data.at( i ) == ')' ) {
       paranthesisBalance--;
-    if ( ( i == m_data.length() && paranthesisBalance == 0 ) || m_data.at(i) == '\n'  || m_data.at(i) == '\r')
+    }
+    if ( ( i == m_data.length() && paranthesisBalance == 0 ) ||
+         m_data.at( i ) == '\n'  || m_data.at( i ) == '\r') {
       break; //command end
-    result.append( m_data.at(i) );
+    }
+    result.append( m_data.at( i ) );
     ++i;
   }
   m_position = i;
@@ -525,16 +552,17 @@ QByteArray ImapStreamParser::readUntilCommandEnd()
 
 void ImapStreamParser::sendContinuationResponse( qint64 size )
 {
-  QByteArray block = "+ Ready for literal data (expecting "
-                   + QByteArray::number( size ) + " bytes)\r\n";
-  m_socket->write(block);
-  m_socket->waitForBytesWritten(30000);
+  QByteArray block = "+ Ready for literal data (expecting " +
+                     QByteArray::number( size ) + " bytes)\r\n";
+  m_socket->write( block );
+  m_socket->waitForBytesWritten( 30000 );
 }
 
 void ImapStreamParser::trimBuffer()
 {
-  if ( m_position < 4096 ) // right() is expensive, so don't do it for every line
+  if ( m_position < 4096 ) { // right() is expensive, so don't do it for every line
     return;
-  m_data = m_data.right(m_data.size()-m_position);
+  }
+  m_data = m_data.right( m_data.size() - m_position );
   m_position = 0;
 }
diff --git a/kimap/imapstreamparser.h b/kimap/imapstreamparser.h
index 7c43d1d..12e97b0 100644
--- a/kimap/imapstreamparser.h
+++ b/kimap/imapstreamparser.h
@@ -36,9 +36,9 @@ namespace KIMAP {
 class ImapParserException : public std::exception
 {
   public:
-    ImapParserException( const char *what ) throw() : mWhat( what ) {}
-    ImapParserException( const QByteArray &what ) throw() : mWhat( what ) {}
-    ImapParserException( const QString &what ) throw() : mWhat( what.toUtf8() ) {}
+    explicit ImapParserException( const char *what ) throw() : mWhat( what ) {}
+    explicit ImapParserException( const QByteArray &what ) throw() : mWhat( what ) {}
+    explicit ImapParserException( const QString &what ) throw() : mWhat( what.toUtf8() ) {}
     ImapParserException( const ImapParserException &other ) throw() : std::exception( other ), mWhat( other.what() ) {}
     virtual ~ImapParserException() throw() {}
     const char *what() const throw() { return mWhat.constData(); }
@@ -86,7 +86,6 @@ class KIMAP_EXPORT ImapStreamParser
      */
     QList<QByteArray> readParenthesizedList();
 
-
     /**
      * Get the next data as a number. This call might block.
      * @param ok true if the data found was a number
@@ -181,7 +180,6 @@ class KIMAP_EXPORT ImapStreamParser
 
     void setData( const QByteArray &data );
 
-
   private:
     void stripLeadingSpaces();
     QByteArray parseQuotedString();
diff --git a/kimap/job.cpp b/kimap/job.cpp
index cd30eec..938c941 100644
--- a/kimap/job.cpp
+++ b/kimap/job.cpp
@@ -22,21 +22,19 @@
 #include "message_p.h"
 #include "session_p.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 
 using namespace KIMAP;
 
 Job::Job( Session *session )
-  : KJob( session ), d_ptr(new JobPrivate(session, i18n("Job")))
+  : KJob( session ), d_ptr( new JobPrivate( session, i18n( "Job" ) ) )
 {
-
 }
 
 Job::Job( JobPrivate &dd )
-  : KJob( dd.m_session ), d_ptr(&dd)
+  : KJob( dd.m_session ), d_ptr( &dd )
 {
-
 }
 
 Job::~Job()
@@ -46,40 +44,40 @@ Job::~Job()
 
 Session *Job::session() const
 {
-  Q_D(const Job);
+  Q_D( const Job );
   return d->m_session;
 }
 
 void Job::start()
 {
-  Q_D(Job);
-  d->sessionInternal()->addJob(this);
+  Q_D( Job );
+  d->sessionInternal()->addJob( this );
 }
 
 void Job::handleResponse(const Message &response)
 {
-  handleErrorReplies(response);
+  handleErrorReplies( response );
 }
 
 void Job::connectionLost()
 {
   setError( KJob::UserDefinedError );
-  setErrorText( i18n("Connection to server lost.") );
+  setErrorText( i18n( "Connection to server lost." ) );
   emitResult();
 }
 
 Job::HandlerResponse Job::handleErrorReplies(const Message &response)
 {
-  Q_D(Job);
-//   qDebug() << response.toString();
+  Q_D( Job );
+//   kDebug() << response.toString();
 
-  if ( !response.content.isEmpty()
-       && d->tags.contains( response.content.first().toString() ) ) {
+  if ( !response.content.isEmpty() &&
+       d->tags.contains( response.content.first().toString() ) ) {
     if ( response.content.size() < 2 ) {
-      setErrorText( i18n("%1 failed, malformed reply from the server.", d->m_name) );
+      setErrorText( i18n( "%1 failed, malformed reply from the server.", d->m_name ) );
     } else if ( response.content[1].toString() != "OK" ) {
       setError( UserDefinedError );
-      setErrorText( i18n("%1 failed, server replied: %2", d->m_name, response.toString().constData()) );
+      setErrorText( i18n( "%1 failed, server replied: %2", d->m_name, response.toString().constData() ) );
     }
     d->tags.removeAll( response.content.first().toString() );
     if ( d->tags.isEmpty() ) { // Only emit result when the last command returned
@@ -92,3 +90,4 @@ Job::HandlerResponse Job::handleErrorReplies(const Message &response)
 }
 
 #include "job.moc"
+
diff --git a/kimap/job.h b/kimap/job.h
index 79dd9a6..6bb5670 100644
--- a/kimap/job.h
+++ b/kimap/job.h
@@ -22,7 +22,7 @@
 
 #include "kimap_export.h"
 
-#include <kjob.h>
+#include <KDE/KJob>
 
 namespace KIMAP {
 
@@ -34,7 +34,7 @@ struct Message;
 class KIMAP_EXPORT Job : public KJob
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(Job)
+  Q_DECLARE_PRIVATE( Job )
 
   friend class SessionPrivate;
 
diff --git a/kimap/job_p.h b/kimap/job_p.h
index b04cf9c..6e4b717 100644
--- a/kimap/job_p.h
+++ b/kimap/job_p.h
@@ -21,7 +21,7 @@
 #define KIMAP_JOB_P_H
 
 #include "session.h"
-#include <klocale.h>
+#include <KDE/KLocalizedString>
 
 namespace KIMAP {
 
@@ -30,7 +30,7 @@ class SessionPrivate;
 class JobPrivate
 {
   public:
-    JobPrivate( Session *session, const QString& name ) : m_session(session)  {
+    JobPrivate( Session *session, const QString& name ) : m_session( session )  {
       m_name = name;
     }
     virtual ~JobPrivate() { }
diff --git a/kimap/listjob.cpp b/kimap/listjob.cpp
index 60f8071..322fc37 100644
--- a/kimap/listjob.cpp
+++ b/kimap/listjob.cpp
@@ -21,7 +21,7 @@
 
 #include <boost/bind.hpp>
 #include <QtCore/QTimer>
-#include <klocale.h>
+#include <KDE/KLocalizedString>
 
 #include "job_p.h"
 #include "message_p.h"
@@ -33,7 +33,7 @@ namespace KIMAP
   class ListJobPrivate : public JobPrivate
   {
     public:
-      ListJobPrivate( ListJob *job, Session *session, const QString& name ) : JobPrivate(session, name), q(job), option(ListJob::NoOption) { }
+      ListJobPrivate( ListJob *job, Session *session, const QString& name ) : JobPrivate( session, name ), q( job ), option( ListJob::NoOption ) { }
       ~ListJobPrivate() { }
 
       void emitPendings()
@@ -63,9 +63,9 @@ namespace KIMAP
 using namespace KIMAP;
 
 ListJob::ListJob( Session *session )
-  : Job( *new ListJobPrivate(this, session, i18n("List")) )
+  : Job( *new ListJobPrivate( this, session, i18n( "List" ) ) )
 {
-  Q_D(ListJob);
+  Q_D( ListJob );
   connect( &d->emitPendingsTimer, SIGNAL(timeout()),
            this, SLOT(emitPendings()) );
 }
@@ -76,8 +76,8 @@ ListJob::~ListJob()
 
 void ListJob::setIncludeUnsubscribed( bool include )
 {
-  Q_D(ListJob);
-  if (include) {
+  Q_D( ListJob );
+  if ( include ) {
     d->option = ListJob::IncludeUnsubscribed;
   } else {
     d->option = ListJob::NoOption;
@@ -86,31 +86,31 @@ void ListJob::setIncludeUnsubscribed( bool include )
 
 bool ListJob::isIncludeUnsubscribed() const
 {
-  Q_D(const ListJob);
+  Q_D( const ListJob );
   return ( d->option == ListJob::IncludeUnsubscribed );
 }
 
 void ListJob::setOption( Option option )
 {
-  Q_D(ListJob);
+  Q_D( ListJob );
   d->option = option;
 }
 
 ListJob::Option ListJob::option() const
 {
-  Q_D(const ListJob);
+  Q_D( const ListJob );
   return d->option;
 }
 
 void ListJob::setQueriedNamespaces( const QList<MailBoxDescriptor> &namespaces )
 {
-  Q_D(ListJob);
+  Q_D( ListJob );
   d->namespaces = namespaces;
 }
 
 QList<MailBoxDescriptor> ListJob::queriedNamespaces() const
 {
-  Q_D(const ListJob);
+  Q_D( const ListJob );
   return d->namespaces;
 }
 
@@ -126,9 +126,9 @@ QMap< MailBoxDescriptor, QList<QByteArray> > ListJob::flags() const
 
 void ListJob::doStart()
 {
-  Q_D(ListJob);
+  Q_D( ListJob );
 
-  switch (d->option) {
+  switch ( d->option ) {
     break;
   case IncludeUnsubscribed:
     d->command = "LIST";
@@ -157,20 +157,20 @@ void ListJob::doStart()
       }
 
       d->tags << d->sessionInternal()->sendCommand( d->command,
-                                                    parameters.arg( descriptor.name+'*' ).toUtf8() );
+                                                    parameters.arg( descriptor.name + '*' ).toUtf8() );
     }
   }
 }
 
 void ListJob::handleResponse( const Message &response )
 {
-  Q_D(ListJob);
+  Q_D( ListJob );
 
   // We can predict it'll be handled by handleErrorReplies() so stop
   // the timer now so that result() will really be the last emitted signal.
-  if ( !response.content.isEmpty()
-       && d->tags.size() == 1
-       && d->tags.contains( response.content.first().toString() ) ) {
+  if ( !response.content.isEmpty() &&
+       d->tags.size() == 1 &&
+       d->tags.contains( response.content.first().toString() ) ) {
     d->emitPendingsTimer.stop();
     d->emitPendings();
   }
@@ -178,7 +178,7 @@ void ListJob::handleResponse( const Message &response )
   if ( handleErrorReplies( response ) == NotHandled ) {
     if ( response.content.size() >= 5 && response.content[1].toString() == d->command ) {
       QList<QByteArray> flags = response.content[2].toList();
-      std::transform( flags.begin(), flags.end(), flags.begin(), boost::bind(&QByteArray::toLower, _1) );
+      std::transform( flags.begin(), flags.end(), flags.begin(), boost::bind( &QByteArray::toLower, _1 ) );
       QByteArray separator = response.content[3].toString();
       if ( separator.isEmpty() ) {
         // Defaults to / for servers reporting an empty list
@@ -186,7 +186,7 @@ void ListJob::handleResponse( const Message &response )
         // only do it for mailboxes with no child.
         separator = "/"; //krazy:exclude=doublequote_chars since a QByteArray
       }
-      Q_ASSERT(separator.size()==1);
+      Q_ASSERT( separator.size() == 1 );
       QByteArray fullName;
       for ( int i=4; i<response.content.size(); i++ ) {
         fullName += response.content[i].toString() + ' ';
@@ -209,12 +209,16 @@ void ListJob::handleResponse( const Message &response )
 void ListJob::convertInboxName(KIMAP::MailBoxDescriptor& descriptor)
 {
     //Inbox must be case sensitive, according to the RFC, so make it always uppercase
-    QStringList pathParts = descriptor.name.split(descriptor.separator);
-    if ( !pathParts.isEmpty() && pathParts[0].compare( QLatin1String("INBOX"), Qt::CaseInsensitive ) == 0 ) {
-       pathParts.removeAt(0);
-       descriptor.name = QLatin1String("INBOX");
-       if ( !pathParts.isEmpty() )
+    QStringList pathParts = descriptor.name.split( descriptor.separator );
+    if ( !pathParts.isEmpty() &&
+         pathParts[0].compare( QLatin1String( "INBOX" ), Qt::CaseInsensitive ) == 0 ) {
+       pathParts.removeAt( 0 );
+       descriptor.name = QLatin1String( "INBOX" );
+       if ( !pathParts.isEmpty() ) {
         descriptor.name += descriptor.separator + pathParts.join( descriptor.separator );
+       }
     }
 }
+
 #include "listjob.moc"
+
diff --git a/kimap/listjob.h b/kimap/listjob.h
index c90cea6..4d87018 100644
--- a/kimap/listjob.h
+++ b/kimap/listjob.h
@@ -37,19 +37,19 @@ struct KIMAP_EXPORT MailBoxDescriptor
 
   inline bool operator==(const MailBoxDescriptor &other) const
   {
-    return other.name==name && other.separator==separator;
+    return other.name == name && other.separator == separator;
   }
 
   inline bool operator<(const MailBoxDescriptor &other) const
   {
-    return other.name<name || (other.name==name && other.separator<separator);
+    return other.name < name || ( other.name == name && other.separator < separator );
   }
 };
 
 class KIMAP_EXPORT ListJob : public Job
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(ListJob)
+  Q_DECLARE_PRIVATE( ListJob )
 
   friend class SessionPrivate;
 
diff --git a/kimap/listrightsjob.cpp b/kimap/listrightsjob.cpp
index 4e79aec..bde9ff0 100644
--- a/kimap/listrightsjob.cpp
+++ b/kimap/listrightsjob.cpp
@@ -19,8 +19,8 @@
 
 #include "listrightsjob.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 
 #include "acljobbase_p.h"
 #include "message_p.h"
@@ -32,7 +32,7 @@ namespace KIMAP
   class ListRightsJobPrivate : public AclJobBasePrivate
   {
     public:
-      ListRightsJobPrivate( Session *session, const QString& name ) : AclJobBasePrivate(session, name), defaultRights(Acl::None) {}
+      ListRightsJobPrivate( Session *session, const QString& name ) : AclJobBasePrivate( session, name ), defaultRights( Acl::None ) {}
       ~ListRightsJobPrivate() { }
 
       Acl::Rights defaultRights;
@@ -44,7 +44,7 @@ namespace KIMAP
 using namespace KIMAP;
 
 ListRightsJob::ListRightsJob( Session *session )
-  : AclJobBase(*new ListRightsJobPrivate(session, i18n("ListRights")))
+  : AclJobBase( *new ListRightsJobPrivate( session, i18n( "ListRights" ) ) )
 {
 
 }
@@ -55,53 +55,53 @@ ListRightsJob::~ListRightsJob()
 
 void ListRightsJob::doStart()
 {
-  Q_D(ListRightsJob);
+  Q_D( ListRightsJob );
 
   d->tags << d->sessionInternal()->sendCommand( "LISTRIGHTS", '\"' + KIMAP::encodeImapFolderName( d->mailBox.toUtf8() ) + "\" \"" + d->id + "\"" );
 }
 
 void ListRightsJob::handleResponse( const Message &response )
 {
-  Q_D(ListRightsJob);
+  Q_D( ListRightsJob );
 
-  if (handleErrorReplies(response) == NotHandled) {
-    if ( response.content.size() >= 4
-         && response.content[1].toString() == "LISTRIGHTS" ) {
+  if ( handleErrorReplies( response ) == NotHandled ) {
+    if ( response.content.size() >= 4 &&
+         response.content[1].toString() == "LISTRIGHTS" ) {
       QByteArray s = response.content[4].toString();
-      d->defaultRights = Acl::rightsFromString(s);
+      d->defaultRights = Acl::rightsFromString( s );
       int i = 5;
-      while ( i < response.content.size()) {
+      while ( i < response.content.size() ) {
         s = response.content[i].toString();
-        d->possibleRights.append(Acl::rightsFromString(s));
+        d->possibleRights.append( Acl::rightsFromString( s ) );
         i++;
       }
    }
   }
 }
 
-
 void ListRightsJob::setIdentifier( const QByteArray &identifier )
 {
-  Q_D(ListRightsJob);
-  d->setIdentifier(identifier);
+  Q_D( ListRightsJob );
+  d->setIdentifier( identifier );
 }
 
 QByteArray ListRightsJob::identifier()
 {
-  Q_D(ListRightsJob);
+  Q_D( ListRightsJob );
   return d->identifier();
 }
 
 Acl::Rights ListRightsJob::defaultRights()
 {
-  Q_D(ListRightsJob);
+  Q_D( ListRightsJob );
   return d->defaultRights;
 }
 
 QList<Acl::Rights> ListRightsJob::possibleRights()
 {
-  Q_D(ListRightsJob);
+  Q_D( ListRightsJob );
   return d->possibleRights;
 }
 
 #include "listrightsjob.moc"
+
diff --git a/kimap/listrightsjob.h b/kimap/listrightsjob.h
index ed4850d..edff595 100644
--- a/kimap/listrightsjob.h
+++ b/kimap/listrightsjob.h
@@ -30,7 +30,6 @@ class Session;
 struct Message;
 class ListRightsJobPrivate;
 
-
 /**
  * Lists the possible and automatic rights for
  * an identifier on a mailbox
@@ -49,7 +48,7 @@ class ListRightsJobPrivate;
 class KIMAP_EXPORT ListRightsJob : public AclJobBase
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(ListRightsJob)
+  Q_DECLARE_PRIVATE( ListRightsJob )
 
   friend class SessionPrivate;
 
diff --git a/kimap/loginjob.cpp b/kimap/loginjob.cpp
index da869be..02634b0 100644
--- a/kimap/loginjob.cpp
+++ b/kimap/loginjob.cpp
@@ -2,7 +2,6 @@
     Copyright (c) 2009 Kevin Ottens <ervin@kde.org>
     Copyright (c) 2009 Andras Mantia <amantia@kde.org>
 
-
     This library is free software; you can redistribute it and/or modify it
     under the terms of the GNU Library General Public License as published by
     the Free Software Foundation; either version 2 of the License, or (at your
@@ -21,8 +20,8 @@
 
 #include "loginjob.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 #include <ktcpsocket.h>
 
 #include "job_p.h"
@@ -59,7 +58,7 @@ namespace KIMAP
         Authenticate
       };
 
-      LoginJobPrivate( LoginJob *job, Session *session, const QString& name ) : JobPrivate(session, name), q(job), encryptionMode(LoginJob::Unencrypted),  authState(Login), plainLoginDisabled(false) {
+      LoginJobPrivate( LoginJob *job, Session *session, const QString& name ) : JobPrivate( session, name ), q( job ), encryptionMode( LoginJob::Unencrypted ), authState( Login ), plainLoginDisabled( false ) {
         conn = 0;
         client_interact = 0;
       }
@@ -93,7 +92,7 @@ using namespace KIMAP;
 
 bool LoginJobPrivate::sasl_interact()
 {
-  kDebug() <<"sasl_interact";
+  kDebug() << "sasl_interact";
   sasl_interact_t *interact = client_interact;
 
   //some mechanisms do not require username && pass, so it doesn't need a popup
@@ -107,23 +106,23 @@ bool LoginJobPrivate::sasl_interact()
   }
 
   interact = client_interact;
-  while( interact->id != SASL_CB_LIST_END ) {
-    kDebug() <<"SASL_INTERACT id:" << interact->id;
-    switch( interact->id ) {
+  while ( interact->id != SASL_CB_LIST_END ) {
+    kDebug() << "SASL_INTERACT id:" << interact->id;
+    switch ( interact->id ) {
       case SASL_CB_AUTHNAME:
         if ( !authorizationName.isEmpty() ) {
-          kDebug() <<"SASL_CB_[AUTHNAME]: '" << authorizationName <<"'";
+          kDebug() << "SASL_CB_[AUTHNAME]: '" << authorizationName << "'";
           interact->result = strdup( authorizationName.toUtf8() );
           interact->len = strlen( (const char *) interact->result );
           break;
         }
       case SASL_CB_USER:
-        kDebug() <<"SASL_CB_[USER|AUTHNAME]: '" << userName <<"'";
+        kDebug() << "SASL_CB_[USER|AUTHNAME]: '" << userName << "'";
         interact->result = strdup( userName.toUtf8() );
         interact->len = strlen( (const char *) interact->result );
         break;
       case SASL_CB_PASS:
-        kDebug() <<"SASL_CB_PASS: [hidden]";
+        kDebug() << "SASL_CB_PASS: [hidden]";
         interact->result = strdup( password.toUtf8() );
         interact->len = strlen( (const char *) interact->result );
         break;
@@ -137,62 +136,64 @@ bool LoginJobPrivate::sasl_interact()
   return true;
 }
 
-
 LoginJob::LoginJob( Session *session )
-  : Job( *new LoginJobPrivate(this, session, i18n("Login")) )
+  : Job( *new LoginJobPrivate( this, session, i18n( "Login" ) ) )
 {
-  Q_D(LoginJob);
-  connect(d->sessionInternal(), SIGNAL(encryptionNegotiationResult(bool)), this, SLOT(sslResponse(bool)));
+  Q_D( LoginJob );
+  connect( d->sessionInternal(), SIGNAL(encryptionNegotiationResult(bool)), this, SLOT(sslResponse(bool)) );
+  kDebug() << this;
 }
 
 LoginJob::~LoginJob()
 {
+  kDebug() << this;
 }
 
 QString LoginJob::userName() const
 {
-  Q_D(const LoginJob);
+  Q_D( const LoginJob );
   return d->userName;
 }
 
 void LoginJob::setUserName( const QString &userName )
 {
-  Q_D(LoginJob);
+  Q_D( LoginJob );
   d->userName = userName;
 }
 
 QString LoginJob::authorizationName() const
 {
-  Q_D(const LoginJob);
+  Q_D( const LoginJob );
   return d->authorizationName;
 }
 
 void LoginJob::setAuthorizationName( const QString& authorizationName )
 {
-  Q_D(LoginJob);
+  Q_D( LoginJob );
   d->authorizationName = authorizationName;
 }
 
 QString LoginJob::password() const
 {
-  Q_D(const LoginJob);
+  Q_D( const LoginJob );
   return d->password;
 }
 
 void LoginJob::setPassword( const QString &password )
 {
-  Q_D(LoginJob);
+  Q_D( LoginJob );
   d->password = password;
 }
 
 void LoginJob::doStart()
 {
-  Q_D(LoginJob);
+  Q_D( LoginJob );
 
+  kDebug() << this;
   // Don't authenticate on a session in the authenticated state
   if ( session()->state() == Session::Authenticated || session()->state() == Session::Selected ) {
     setError( UserDefinedError );
-    setErrorText( i18n("IMAP session in the wrong state for authentication") );
+    setErrorText( i18n( "IMAP session in the wrong state for authentication" ) );
     emitResult();
     return;
   }
@@ -209,53 +210,57 @@ void LoginJob::doStart()
   // (so for instance we won't issue another STARTTLS for nothing if that's
   // not needed)
   case KTcpSocket::SslV2:
-    if ( encryptionMode==SslV2 ) {
+    if ( encryptionMode == SslV2 ) {
       encryptionMode = Unencrypted;
     }
     break;
   case KTcpSocket::SslV3:
-    if ( encryptionMode==SslV3 ) {
+    if ( encryptionMode == SslV3 ) {
       encryptionMode = Unencrypted;
     }
     break;
   case KTcpSocket::TlsV1:
-    if ( encryptionMode==TlsV1 ) {
+    if ( encryptionMode == TlsV1 ) {
       encryptionMode = Unencrypted;
     }
     break;
   case KTcpSocket::AnySslVersion:
-    if ( encryptionMode==AnySslVersion ) {
+    if ( encryptionMode == AnySslVersion ) {
       encryptionMode = Unencrypted;
     }
     break;
   }
 
-  if (encryptionMode == SslV2
-   || encryptionMode == SslV3
-   || encryptionMode == SslV3_1
-   || encryptionMode == AnySslVersion) {
+  if ( encryptionMode == SslV2 ||
+       encryptionMode == SslV3 ||
+       encryptionMode == SslV3_1 ||
+       encryptionMode == AnySslVersion ) {
     KTcpSocket::SslVersion version = KTcpSocket::SslV2;
-    if (encryptionMode == SslV3)
+    if ( encryptionMode == SslV3 ) {
       version = KTcpSocket::SslV3;
-    if (encryptionMode == SslV3_1)
+    }
+    if ( encryptionMode == SslV3_1 ) {
       version = KTcpSocket::SslV3_1;
-    if (encryptionMode == AnySslVersion)
+    }
+    if ( encryptionMode == AnySslVersion ) {
       version = KTcpSocket::AnySslVersion;
-    d->sessionInternal()->startSsl(version);
+    }
+    d->sessionInternal()->startSsl( version );
 
-  } else if (encryptionMode == TlsV1) {
+  } else if ( encryptionMode == TlsV1 ) {
     d->authState = LoginJobPrivate::StartTls;
     d->tags << d->sessionInternal()->sendCommand( "STARTTLS" );
 
-  } else  if (encryptionMode == Unencrypted ) {
-    if (d->authMode.isEmpty()) {
+  } else  if ( encryptionMode == Unencrypted  ) {
+    if ( d->authMode.isEmpty() ) {
       d->authState = LoginJobPrivate::Login;
+      kDebug() << "sending LOGIN";
       d->tags << d->sessionInternal()->sendCommand( "LOGIN",
-                                                  '"'+quoteIMAP( d->userName ).toUtf8()+'"'
-                                                 +' '
-                                                 +'"'+quoteIMAP(d->password ).toUtf8()+'"' );
+                                                    '"' + quoteIMAP( d->userName ).toUtf8() + '"' +
+                                                    ' ' +
+                                                    '"' + quoteIMAP( d->password  ).toUtf8() + '"' );
     } else {
-      if (!d->startAuthentication()) {
+      if ( !d->startAuthentication() ) {
         emitResult();
       }
     }
@@ -264,17 +269,18 @@ void LoginJob::doStart()
 
 void LoginJob::handleResponse( const Message &response )
 {
-  Q_D(LoginJob);
+  Q_D( LoginJob );
 
-  if ( response.content.isEmpty() )
+  if ( response.content.isEmpty() ) {
     return;
+  }
 
   //set the actual command name for standard responses
-  QString commandName = i18n("Login");
-  if (d->authState == LoginJobPrivate::Capability) {
-    commandName = i18n("Capability");
-  } else if (d->authState == LoginJobPrivate::StartTls) {
-    commandName = i18n("StartTls");
+  QString commandName = i18n( "Login" );
+  if ( d->authState == LoginJobPrivate::Capability ) {
+    commandName = i18n( "Capability" );
+  } else if ( d->authState == LoginJobPrivate::StartTls ) {
+    commandName = i18n( "StartTls" );
   }
 
   enum ResponseCode {
@@ -286,36 +292,41 @@ void LoginJob::handleResponse( const Message &response )
   };
 
   QByteArray tag = response.content.first().toString();
-  ResponseCode code;
+  ResponseCode code = OK;
+
+  kDebug() << commandName << tag;
 
   if ( tag == "+" ) {
     code = CONTINUATION;
   } else if ( tag == "*" ) {
-    if ( response.content.size() < 2 )
+    if ( response.content.size() < 2 ) {
       code = MALFORMED; // Received empty untagged response
-    else
+    } else {
       code = UNTAGGED;
-  } else if ( d->tags.contains(tag) ) {
-    if ( response.content.size() < 2 )
+    }
+  } else if ( d->tags.contains( tag ) ) {
+    if ( response.content.size() < 2 ) {
       code = MALFORMED;
-    else if ( response.content[1].toString() == "OK" )
+    } else if ( response.content[1].toString() == "OK" ) {
       code = OK;
-    else
+    } else {
       code = ERR;
+    }
   }
 
-  switch (code) {
+  switch ( code ) {
     case MALFORMED:
       // We'll handle it later
       break;
 
     case ERR:
       //server replied with NO or BAD for SASL authentication
-      if (d->authState == LoginJobPrivate::Authenticate)
+      if ( d->authState == LoginJobPrivate::Authenticate ) {
         sasl_dispose( &d->conn );
+      }
 
       setError( UserDefinedError );
-      setErrorText( i18n("%1 failed, server replied: %2", commandName, response.toString().constData()) );
+      setErrorText( i18n( "%1 failed, server replied: %2", commandName, response.toString().constData() ) );
       emitResult();
       return;
 
@@ -323,11 +334,12 @@ void LoginJob::handleResponse( const Message &response )
       // The only untagged response interesting for us here is CAPABILITY
       if ( response.content[1].toString() == "CAPABILITY" ) {
         QList<Message::Part>::const_iterator p = response.content.begin() + 2;
-        while (p != response.content.end()) {
+        while ( p != response.content.end() ) {
           QString capability = p->toString();
           d->capabilities << capability;
-          if (capability == "LOGINDISABLED")
+          if ( capability == "LOGINDISABLED" ) {
             d->plainLoginDisabled = true;
+          }
           ++p;
         }
         kDebug() << "Capabilities updated: " << d->capabilities;
@@ -335,7 +347,7 @@ void LoginJob::handleResponse( const Message &response )
       break;
 
     case CONTINUATION:
-      if (d->authState != LoginJobPrivate::Authenticate) {
+      if ( d->authState != LoginJobPrivate::Authenticate ) {
         // Received unexpected continuation response for something
         // other than AUTHENTICATE command
         code = MALFORMED;
@@ -343,7 +355,7 @@ void LoginJob::handleResponse( const Message &response )
       }
 
       if ( d->authMode == QLatin1String( "PLAIN" ) ) {
-        if ( response.content.size()>1 && response.content.at( 1 ).toString()=="OK" ) {
+        if ( response.content.size()>1 && response.content.at( 1 ).toString() == "OK" ) {
           return;
         }
         QByteArray challengeResponse;
@@ -357,7 +369,7 @@ void LoginJob::handleResponse( const Message &response )
         challengeResponse = challengeResponse.toBase64();
         d->sessionInternal()->sendData( challengeResponse );
       } else if ( response.content.size() >= 2 ) {
-        if (!d->answerChallenge(QByteArray::fromBase64(response.content[1].toString()))) {
+        if ( !d->answerChallenge( QByteArray::fromBase64( response.content[1].toString() ) ) ) {
           emitResult(); //error, we're done
         }
       } else {
@@ -368,41 +380,41 @@ void LoginJob::handleResponse( const Message &response )
 
     case OK:
 
-      switch (d->authState) {
+      switch ( d->authState ) {
         case LoginJobPrivate::StartTls:
-          d->sessionInternal()->startSsl(KTcpSocket::TlsV1);
+          d->sessionInternal()->startSsl( KTcpSocket::TlsV1 );
           break;
 
         case LoginJobPrivate::Capability:
           //cleartext login, if enabled
-          if (d->authMode.isEmpty()) {
-            if (d->plainLoginDisabled) {
+          if ( d->authMode.isEmpty() ) {
+            if ( d->plainLoginDisabled ) {
               setError( UserDefinedError );
-              setErrorText( i18n("Login failed, plain login is disabled by the server.") );
+              setErrorText( i18n( "Login failed, plain login is disabled by the server." ) );
               emitResult();
             } else {
               d->authState = LoginJobPrivate::Login;
               d->tags << d->sessionInternal()->sendCommand( "LOGIN",
-                                                          '"'+quoteIMAP( d->userName ).toUtf8()+'"'
-                                                         +' '
-                                                         +'"'+quoteIMAP( d->password ).toUtf8()+'"');
+                                                            '"' + quoteIMAP( d->userName ).toUtf8() + '"' +
+                                                            ' ' +
+                                                            '"' + quoteIMAP( d->password ).toUtf8() + '"' );
             }
           } else {
             bool authModeSupported = false;
             //find the selected SASL authentication method
-            Q_FOREACH(const QString &capability, d->capabilities) {
-              if (capability.startsWith(QLatin1String("AUTH="))) {
-                if (capability.mid(5) == d->authMode) {
+            Q_FOREACH ( const QString &capability, d->capabilities ) {
+              if ( capability.startsWith( QLatin1String( "AUTH=" ) ) ) {
+                if ( capability.mid( 5 ) == d->authMode ) {
                   authModeSupported = true;
                   break;
                 }
               }
             }
-            if (!authModeSupported) {
+            if ( !authModeSupported ) {
               setError( UserDefinedError );
-              setErrorText( i18n("Login failed, authentication mode %1 is not supported by the server.", d->authMode) );
+              setErrorText( i18n( "Login failed, authentication mode %1 is not supported by the server.", d->authMode ) );
               emitResult();
-            } else if (!d->startAuthentication()) {
+            } else if ( !d->startAuthentication() ) {
               emitResult(); //problem, we're done
             }
           }
@@ -421,7 +433,7 @@ void LoginJob::handleResponse( const Message &response )
   }
 
   if ( code == MALFORMED ) {
-    setErrorText( i18n("%1 failed, malformed reply from the server.", commandName) );
+    setErrorText( i18n( "%1 failed, malformed reply from the server.", commandName ) );
     emitResult();
   }
 }
@@ -429,9 +441,9 @@ void LoginJob::handleResponse( const Message &response )
 bool LoginJobPrivate::startAuthentication()
 {
   //SASL authentication
-  if (!initSASL()) {
+  if ( !initSASL() ) {
     q->setError( LoginJob::UserDefinedError );
-    q->setErrorText( i18n("Login failed, client cannot initialize the SASL library.") );
+    q->setErrorText( i18n( "Login failed, client cannot initialize the SASL library." ) );
     return false;
   }
 
@@ -442,14 +454,14 @@ bool LoginJobPrivate::startAuthentication()
 
   int result = sasl_client_new( "imap", m_session->hostName().toLatin1(), 0, 0, callbacks, 0, &conn );
   if ( result != SASL_OK ) {
-    kDebug() <<"sasl_client_new failed with:" << result;
+    kDebug() << "sasl_client_new failed with:" << result;
     q->setError( LoginJob::UserDefinedError );
     q->setErrorText( QString::fromUtf8( sasl_errdetail( conn ) ) );
     return false;
   }
 
   do {
-    result = sasl_client_start(conn, authMode.toLatin1(), &client_interact, capabilities.contains("SASL-IR") ? &out : 0, &outlen, &mechusing);
+    result = sasl_client_start( conn, authMode.toLatin1(), &client_interact, capabilities.contains( "SASL-IR" ) ? &out : 0, &outlen, &mechusing );
 
     if ( result == SASL_INTERACT ) {
       if ( !sasl_interact() ) {
@@ -461,7 +473,7 @@ bool LoginJobPrivate::startAuthentication()
   } while ( result == SASL_INTERACT );
 
   if ( result != SASL_CONTINUE && result != SASL_OK ) {
-    kDebug() <<"sasl_client_start failed with:" << result;
+    kDebug() << "sasl_client_start failed with:" << result;
     q->setError( LoginJob::UserDefinedError );
     q->setErrorText( QString::fromUtf8( sasl_errdetail( conn ) ) );
     sasl_dispose( &conn );
@@ -487,12 +499,12 @@ bool LoginJobPrivate::answerChallenge(const QByteArray &data)
   const char *out = 0;
   uint outlen = 0;
   do {
-    result = sasl_client_step(conn, challenge.isEmpty() ? 0 : challenge.data(),
-                              challenge.size(),
-                              &client_interact,
-                              &out, &outlen);
+    result = sasl_client_step( conn, challenge.isEmpty() ? 0 : challenge.data(),
+                               challenge.size(),
+                               &client_interact,
+                               &out, &outlen );
 
-    if (result == SASL_INTERACT) {
+    if ( result == SASL_INTERACT ) {
       if ( !sasl_interact() ) {
         q->setError( LoginJob::UserDefinedError ); //TODO: check up the actual error
         sasl_dispose( &conn );
@@ -502,7 +514,7 @@ bool LoginJobPrivate::answerChallenge(const QByteArray &data)
   } while ( result == SASL_INTERACT );
 
   if ( result != SASL_CONTINUE && result != SASL_OK ) {
-    kDebug() <<"sasl_client_step failed with:" << result;
+    kDebug() << "sasl_client_step failed with:" << result;
     q->setError( LoginJob::UserDefinedError ); //TODO: check up the actual error
     q->setErrorText( QString::fromUtf8( sasl_errdetail( conn ) ) );
     sasl_dispose( &conn );
@@ -519,12 +531,12 @@ bool LoginJobPrivate::answerChallenge(const QByteArray &data)
 
 void LoginJobPrivate::sslResponse(bool response)
 {
-  if (response) {
+  if ( response ) {
     authState = LoginJobPrivate::Capability;
     tags << sessionInternal()->sendCommand( "CAPABILITY" );
   } else {
     q->setError( LoginJob::UserDefinedError );
-    q->setErrorText( i18n("Login failed, TLS negotiation failed." ));
+    q->setErrorText( i18n( "Login failed, TLS negotiation failed." ) );
     encryptionMode = LoginJob::Unencrypted;
     q->emitResult();
   }
@@ -532,21 +544,20 @@ void LoginJobPrivate::sslResponse(bool response)
 
 void LoginJob::setEncryptionMode(EncryptionMode mode)
 {
-  Q_D(LoginJob);
+  Q_D( LoginJob );
   d->encryptionMode = mode;
 }
 
 LoginJob::EncryptionMode LoginJob::encryptionMode()
 {
-  Q_D(LoginJob);
+  Q_D( LoginJob );
   return d->encryptionMode;
 }
 
 void LoginJob::setAuthenticationMode(AuthenticationMode mode)
 {
-  Q_D(LoginJob);
-  switch (mode)
-  {
+  Q_D( LoginJob );
+  switch ( mode ) {
     case ClearText: d->authMode = "";
       break;
     case Login: d->authMode = "LOGIN";
@@ -568,13 +579,13 @@ void LoginJob::setAuthenticationMode(AuthenticationMode mode)
 
 void LoginJob::connectionLost()
 {
-  Q_D(LoginJob);
+  Q_D( LoginJob );
 
   //don't emit the result if the connection was lost before getting the tls result, as it can mean
   //the TLS handshake failed and the socket was reconnected in normal mode
-  if (d->authState != LoginJobPrivate::StartTls) {
+  if ( d->authState != LoginJobPrivate::StartTls ) {
     setError( ERR_COULD_NOT_CONNECT );
-    setErrorText( i18n("Connection to server lost.") );
+    setErrorText( i18n( "Connection to server lost." ) );
     emitResult();
   }
 
@@ -585,25 +596,26 @@ void LoginJobPrivate::saveServerGreeting(const Message &response)
   // Concatenate the parts of the server response into a string, while dropping the first two parts
   // (the response tag and the "OK" code), and being careful not to add useless extra whitespace.
 
-  for ( int i=2; i<response.content.size(); i++) {
-    if ( response.content.at(i).type()==Message::Part::List ) {
-      serverGreeting+='(';
-      foreach ( const QByteArray &item, response.content.at(i).toList() ) {
-        serverGreeting+=item+' ';
+  for ( int i = 2; i < response.content.size(); i++ ) {
+    if ( response.content.at( i ).type() == Message::Part::List ) {
+      serverGreeting += '(';
+      foreach ( const QByteArray &item, response.content.at( i ).toList() ) {
+        serverGreeting += item + ' ';
       }
-      serverGreeting.chop(1);
-      serverGreeting+=") ";
+      serverGreeting.chop( 1 );
+      serverGreeting += ") ";
     } else {
-      serverGreeting+=response.content.at(i).toString()+' ';
+      serverGreeting+=response.content.at( i ).toString() + ' ';
     }
   }
-  serverGreeting.chop(1);
+  serverGreeting.chop( 1 );
 }
 
 QString LoginJob::serverGreeting() const
 {
-  Q_D(const LoginJob);
+  Q_D( const LoginJob );
   return d->serverGreeting;
 }
 
 #include "loginjob.moc"
+
diff --git a/kimap/loginjob.h b/kimap/loginjob.h
index 6064214..2c6040a 100644
--- a/kimap/loginjob.h
+++ b/kimap/loginjob.h
@@ -34,7 +34,7 @@ class LoginJobPrivate;
 class KIMAP_EXPORT LoginJob : public Job
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(LoginJob)
+  Q_DECLARE_PRIVATE( LoginJob )
 
   friend class SessionPrivate;
 
diff --git a/kimap/logoutjob.cpp b/kimap/logoutjob.cpp
index 9f191dd..5c9bc19 100644
--- a/kimap/logoutjob.cpp
+++ b/kimap/logoutjob.cpp
@@ -19,7 +19,7 @@
 
 #include "logoutjob.h"
 
-#include <klocale.h>
+#include <KDE/KLocalizedString>
 
 #include "job_p.h"
 #include "message_p.h"
@@ -30,7 +30,7 @@ namespace KIMAP
   class LogoutJobPrivate : public JobPrivate
   {
     public:
-      LogoutJobPrivate( Session *session, const QString& name ) : JobPrivate(session, name) { }
+      LogoutJobPrivate( Session *session, const QString& name ) : JobPrivate( session, name ) { }
       ~LogoutJobPrivate() { }
   };
 }
@@ -38,7 +38,7 @@ namespace KIMAP
 using namespace KIMAP;
 
 LogoutJob::LogoutJob( Session *session )
-  : Job( *new LogoutJobPrivate(session, i18n("Logout")) )
+  : Job( *new LogoutJobPrivate( session, i18n( "Logout" ) ) )
 {
 }
 
@@ -48,7 +48,7 @@ LogoutJob::~LogoutJob()
 
 void LogoutJob::doStart()
 {
-  Q_D(LogoutJob);
+  Q_D( LogoutJob );
   d->tags << d->sessionInternal()->sendCommand( "LOGOUT" );
 }
 
@@ -58,3 +58,4 @@ void LogoutJob::connectionLost()
 }
 
 #include "logoutjob.moc"
+
diff --git a/kimap/logoutjob.h b/kimap/logoutjob.h
index e3f6553..288400f 100644
--- a/kimap/logoutjob.h
+++ b/kimap/logoutjob.h
@@ -32,7 +32,7 @@ class LogoutJobPrivate;
 class KIMAP_EXPORT LogoutJob : public Job
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(LogoutJob)
+  Q_DECLARE_PRIVATE( LogoutJob )
 
   friend class SessionPrivate;
 
diff --git a/kimap/message_p.h b/kimap/message_p.h
index 9d703bf..e6dd502 100644
--- a/kimap/message_p.h
+++ b/kimap/message_p.h
@@ -34,9 +34,9 @@ struct Message
         enum Type { String = 0, List };
 
         explicit Part(const QByteArray &string)
-          : m_type(String), m_string(string) { }
+          : m_type( String ), m_string( string ) { }
         explicit Part(const QList<QByteArray> &list)
-          : m_type(List), m_list(list) { }
+          : m_type( List ), m_list( list ) { }
 
         inline Type type() const { return m_type; }
         inline QByteArray toString() const { return m_string; }
@@ -53,22 +53,22 @@ struct Message
       QByteArray result;
 
       foreach ( const Part &part, content ) {
-        if ( part.type()==Part::List ) {
-          result+='(';
+        if ( part.type() == Part::List ) {
+          result += '(';
           foreach ( const QByteArray &item, part.toList() ) {
-            result+= ' ';
-            result+= item;
+            result += ' ';
+            result += item;
           }
-          result+=" ) ";
+          result += " ) ";
         } else {
-          result+= part.toString()+' ';
+          result += part.toString() + ' ';
         }
       }
 
       if ( !responseCode.isEmpty() ) {
         result+="[ ";
         foreach ( const Part &part, responseCode ) {
-          if ( part.type()==Part::List ) {
+          if ( part.type() == Part::List ) {
             result+='(';
             foreach ( const QByteArray &item, part.toList() ) {
               result+= ' ';
@@ -76,7 +76,7 @@ struct Message
             }
             result+=" ) ";
           } else {
-            result+= part.toString()+' ';
+            result+= part.toString() + ' ';
           }
         }
         result+=" ]";
@@ -91,7 +91,7 @@ struct Message
 
 }
 
-Q_DECLARE_METATYPE(KIMAP::Message)
+Q_DECLARE_METATYPE( KIMAP::Message )
 static const int _kimap_messageTypeId = qRegisterMetaType<KIMAP::Message>();
 
 #endif
diff --git a/kimap/metadatajobbase.cpp b/kimap/metadatajobbase.cpp
index fa9dc53..bc7a8d5 100644
--- a/kimap/metadatajobbase.cpp
+++ b/kimap/metadatajobbase.cpp
@@ -22,50 +22,48 @@
 #include "message_p.h"
 #include "session_p.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 
 using namespace KIMAP;
 
 MetaDataJobBase::MetaDataJobBase( Session *session )
-  : Job( *new MetaDataJobBasePrivate(session, i18n("MetaDataJobBase")) )
+  : Job( *new MetaDataJobBasePrivate( session, i18n( "MetaDataJobBase" ) ) )
 {
 }
 
-
 MetaDataJobBase::MetaDataJobBase( JobPrivate &dd )
-  : Job(dd)
+  : Job( dd )
 {
-
 }
 
 MetaDataJobBase::~MetaDataJobBase()
 {
 }
 
-
 void MetaDataJobBase::setMailBox( const QString &mailBox )
 {
-  Q_D(MetaDataJobBase);
+  Q_D( MetaDataJobBase );
   d->mailBox = mailBox;
 }
 
 QString MetaDataJobBase::mailBox() const
 {
-  Q_D(const MetaDataJobBase);
+  Q_D( const MetaDataJobBase );
   return d->mailBox;
 }
 
 void MetaDataJobBase::setServerCapability(const ServerCapability& capability)
 {
-  Q_D(MetaDataJobBase);
+  Q_D( MetaDataJobBase );
   d->serverCapability = capability;
 }
 
 MetaDataJobBase::ServerCapability MetaDataJobBase::serverCapability() const
 {
-  Q_D(const MetaDataJobBase);
+  Q_D( const MetaDataJobBase );
   return d->serverCapability;
 }
 
 #include "metadatajobbase.moc"
+
diff --git a/kimap/metadatajobbase.h b/kimap/metadatajobbase.h
index f7ad6e2..de46736 100644
--- a/kimap/metadatajobbase.h
+++ b/kimap/metadatajobbase.h
@@ -47,7 +47,7 @@ class MetaDataJobBasePrivate;
 class KIMAP_EXPORT MetaDataJobBase : public Job
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(MetaDataJobBase)
+  Q_DECLARE_PRIVATE( MetaDataJobBase )
 
   friend class SessionPrivate;
 
diff --git a/kimap/metadatajobbase_p.h b/kimap/metadatajobbase_p.h
index 983a344..140ef20 100644
--- a/kimap/metadatajobbase_p.h
+++ b/kimap/metadatajobbase_p.h
@@ -30,7 +30,7 @@ namespace KIMAP
   class MetaDataJobBasePrivate : public JobPrivate
   {
     public:
-      MetaDataJobBasePrivate( Session *session, const QString& name ) : JobPrivate(session, name), serverCapability(MetaDataJobBase::Metadata)
+      MetaDataJobBasePrivate( Session *session, const QString& name ) : JobPrivate( session, name ), serverCapability( MetaDataJobBase::Metadata )
       {}
 
       ~MetaDataJobBasePrivate() { }
diff --git a/kimap/myrightsjob.cpp b/kimap/myrightsjob.cpp
index 46354ae..49790b3 100644
--- a/kimap/myrightsjob.cpp
+++ b/kimap/myrightsjob.cpp
@@ -19,8 +19,8 @@
 
 #include "myrightsjob.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 
 #include "acljobbase_p.h"
 #include "message_p.h"
@@ -32,7 +32,7 @@ namespace KIMAP
   class MyRightsJobPrivate : public AclJobBasePrivate
   {
     public:
-      MyRightsJobPrivate( Session *session, const QString& name ) : AclJobBasePrivate(session, name), myRights(Acl::None) {}
+      MyRightsJobPrivate( Session *session, const QString& name ) : AclJobBasePrivate( session, name ), myRights( Acl::None ) {}
       ~MyRightsJobPrivate() { }
 
       Acl::Rights myRights;
@@ -42,7 +42,7 @@ namespace KIMAP
 using namespace KIMAP;
 
 MyRightsJob::MyRightsJob( Session *session )
-  : AclJobBase( *new MyRightsJobPrivate(session, i18n("MyRights") ))
+  : AclJobBase( *new MyRightsJobPrivate( session, i18n( "MyRights" ) ) )
 {
 }
 
@@ -52,18 +52,18 @@ MyRightsJob::~MyRightsJob()
 
 void MyRightsJob::doStart()
 {
-  Q_D(MyRightsJob);
+  Q_D( MyRightsJob );
 
-  d->tags << d->sessionInternal()->sendCommand( "MYRIGHTS", '\"' + KIMAP::encodeImapFolderName( d->mailBox.toUtf8() ) + '\"');
+  d->tags << d->sessionInternal()->sendCommand( "MYRIGHTS", '\"' + KIMAP::encodeImapFolderName( d->mailBox.toUtf8() ) + '\"' );
 }
 
 void MyRightsJob::handleResponse( const Message &response )
 {
-  Q_D(MyRightsJob);
+  Q_D( MyRightsJob );
 
-  if (handleErrorReplies(response) == NotHandled) {
-    if ( response.content.size() == 4
-         && response.content[1].toString() == "MYRIGHTS" ) {
+  if ( handleErrorReplies( response ) == NotHandled ) {
+    if ( response.content.size() == 4 &&
+         response.content[1].toString() == "MYRIGHTS" ) {
       d->myRights = Acl::rightsFromString( response.content[3].toString() );
     }
   }
@@ -71,14 +71,15 @@ void MyRightsJob::handleResponse( const Message &response )
 
 bool MyRightsJob::hasRightEnabled(Acl::Right right)
 {
-  Q_D(MyRightsJob);
+  Q_D( MyRightsJob );
   return d->myRights & right;
 }
 
 Acl::Rights MyRightsJob::rights()
 {
-  Q_D(MyRightsJob);
+  Q_D( MyRightsJob );
   return d->myRights;
 }
 
 #include "myrightsjob.moc"
+
diff --git a/kimap/myrightsjob.h b/kimap/myrightsjob.h
index 4e57d0e..24973d5 100644
--- a/kimap/myrightsjob.h
+++ b/kimap/myrightsjob.h
@@ -56,7 +56,7 @@ class MyRightsJobPrivate;
 class KIMAP_EXPORT MyRightsJob : public AclJobBase
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(MyRightsJob)
+  Q_DECLARE_PRIVATE( MyRightsJob )
 
   friend class SessionPrivate;
 
diff --git a/kimap/namespacejob.cpp b/kimap/namespacejob.cpp
index 639e55d..47b3930 100644
--- a/kimap/namespacejob.cpp
+++ b/kimap/namespacejob.cpp
@@ -19,8 +19,8 @@
 
 #include "namespacejob.h"
 
-#include <kdebug.h>
-#include <klocale.h>
+#include <KDE/KDebug>
+#include <KDE/KLocalizedString>
 
 #include "job_p.h"
 #include "listjob.h"
@@ -34,7 +34,7 @@ namespace KIMAP
   class NamespaceJobPrivate : public JobPrivate
   {
     public:
-      NamespaceJobPrivate( Session *session,  const QString& name ) : JobPrivate(session, name) { }
+      NamespaceJobPrivate( Session *session,  const QString& name ) : JobPrivate( session, name ) { }
       ~NamespaceJobPrivate() { }
 
       QList<MailBoxDescriptor> processNamespaceList( const QList<QByteArray> &namespaceList )
@@ -55,7 +55,7 @@ namespace KIMAP
                 descriptor.separator = QChar( parts[1][0] );
 
                 result << descriptor;
-            } catch (KIMAP::ImapParserException e) {
+            } catch ( KIMAP::ImapParserException e ) {
                 qWarning() << "The stream parser raised an exception during namespace list parsing:" << e.what();
                 qWarning() << "namespacelist:" << namespaceList;
             }
@@ -74,7 +74,7 @@ namespace KIMAP
 using namespace KIMAP;
 
 NamespaceJob::NamespaceJob( Session *session )
-  : Job( *new NamespaceJobPrivate(session, i18n("Namespace")) )
+  : Job( *new NamespaceJobPrivate( session, i18n( "Namespace" ) ) )
 {
 }
 
@@ -84,25 +84,25 @@ NamespaceJob::~NamespaceJob()
 
 QList<MailBoxDescriptor> NamespaceJob::personalNamespaces() const
 {
-  Q_D(const NamespaceJob);
+  Q_D( const NamespaceJob );
   return d->personalNamespaces;
 }
 
 QList<MailBoxDescriptor> NamespaceJob::userNamespaces() const
 {
-  Q_D(const NamespaceJob);
+  Q_D( const NamespaceJob );
   return d->userNamespaces;
 }
 
 QList<MailBoxDescriptor> NamespaceJob::sharedNamespaces() const
 {
-  Q_D(const NamespaceJob);
+  Q_D( const NamespaceJob );
   return d->sharedNamespaces;
 }
 
 bool NamespaceJob::containsEmptyNamespace() const
 {
-  Q_D(const NamespaceJob);
+  Q_D( const NamespaceJob );
   QList<MailBoxDescriptor> completeList = d->personalNamespaces
                                         + d->userNamespaces
                                         + d->sharedNamespaces;
@@ -118,16 +118,16 @@ bool NamespaceJob::containsEmptyNamespace() const
 
 void NamespaceJob::doStart()
 {
-  Q_D(NamespaceJob);
+  Q_D( NamespaceJob );
   d->tags << d->sessionInternal()->sendCommand( "NAMESPACE" );
 }
 
 void NamespaceJob::handleResponse( const Message &response )
 {
-  Q_D(NamespaceJob);
-  if (handleErrorReplies(response) == NotHandled) {
-    if ( response.content.size() >= 5
-      && response.content[1].toString()=="NAMESPACE" ) {
+  Q_D( NamespaceJob );
+  if ( handleErrorReplies( response ) == NotHandled ) {
+    if ( response.content.size() >= 5 &&
+         response.content[1].toString() == "NAMESPACE" ) {
       // Personal namespaces
       d->personalNamespaces = d->processNamespaceList( response.content[2].toList() );
 
@@ -141,3 +141,4 @@ void NamespaceJob::handleResponse( const Message &response )
 }
 
 #include "namespacejob.moc"
+
diff --git a/kimap/namespacejob.h b/kimap/namespacejob.h
index 130c788..429d1d8 100644
--- a/kimap/namespacejob.h
+++ b/kimap/namespacejob.h
@@ -34,7 +34,7 @@ class NamespaceJobPrivate;
 class KIMAP_EXPORT NamespaceJob : public Job
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(NamespaceJob)
+  Q_DECLARE_PRIVATE( NamespaceJob )
 
   friend class SessionPrivate;
 
diff --git a/kimap/quotajobbase.cpp b/kimap/quotajobbase.cpp
index 16737ce..5ae6d56 100644
--- a/kimap/quotajobbase.cpp
+++ b/kimap/quotajobbase.cpp
@@ -22,8 +22,8 @@
 #include "message_p.h"
 #include "session_p.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 
 using namespace KIMAP;
 
@@ -37,7 +37,7 @@ QMap<QByteArray, QPair<qint64, qint64> > QuotaJobBasePrivate::readQuota( const M
     QByteArray resource = quotas[i].toUpper();
     qint64 usage = quotas[i+1].toInt();
     qint64 limit = quotas[i+2].toInt();
-    quotaMap[resource] = qMakePair(usage, limit);
+    quotaMap[resource] = qMakePair( usage, limit );
     i += 3;
   }
 
@@ -45,45 +45,40 @@ QMap<QByteArray, QPair<qint64, qint64> > QuotaJobBasePrivate::readQuota( const M
 }
 
 QuotaJobBase::QuotaJobBase( Session *session )
-  : Job( *new QuotaJobBasePrivate(session, i18n("QuotaJobBase")) )
+  : Job( *new QuotaJobBasePrivate( session, i18n( "QuotaJobBase" ) ) )
 {
 }
 
-
 QuotaJobBase::QuotaJobBase( JobPrivate &dd )
-  : Job(dd)
+  : Job( dd )
 {
-
 }
 
 QuotaJobBase::~QuotaJobBase()
 {
 }
 
-
 qint64 QuotaJobBase::usage(const QByteArray& resource)
 {
-  Q_D(QuotaJobBase);
+  Q_D( QuotaJobBase );
 
   QByteArray r = resource.toUpper();
 
-  if (d->quota.contains(r)) {
+  if ( d->quota.contains( r ) ) {
      return d->quota[r].first;
   }
-
   return -1;
 }
 
 qint64 QuotaJobBase::limit(const QByteArray& resource)
 {
-  Q_D(QuotaJobBase);
+  Q_D( QuotaJobBase );
 
   QByteArray r = resource.toUpper();
 
-  if (d->quota.contains(r)) {
+  if ( d->quota.contains( r ) ) {
     return d->quota[r].second;
   }
-
   return -1;
 }
 
diff --git a/kimap/quotajobbase.h b/kimap/quotajobbase.h
index 640ca0d..29b06bb 100644
--- a/kimap/quotajobbase.h
+++ b/kimap/quotajobbase.h
@@ -42,7 +42,7 @@ class QuotaJobBasePrivate;
 class KIMAP_EXPORT QuotaJobBase : public Job
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(QuotaJobBase)
+  Q_DECLARE_PRIVATE( QuotaJobBase )
 
   friend class SessionPrivate;
 
diff --git a/kimap/quotajobbase_p.h b/kimap/quotajobbase_p.h
index aedc752..dc4313b 100644
--- a/kimap/quotajobbase_p.h
+++ b/kimap/quotajobbase_p.h
@@ -24,12 +24,14 @@
 #include "message_p.h"
 #include "session.h"
 
+#include <QMap>
+
 namespace KIMAP
 {
   class QuotaJobBasePrivate : public JobPrivate
   {
     public:
-      QuotaJobBasePrivate( Session *session, const QString& name ) : JobPrivate(session, name)
+      QuotaJobBasePrivate( Session *session, const QString& name ) : JobPrivate( session, name )
       {}
 
       ~QuotaJobBasePrivate() { }
diff --git a/kimap/renamejob.cpp b/kimap/renamejob.cpp
index 1ec357d..a8c8505 100644
--- a/kimap/renamejob.cpp
+++ b/kimap/renamejob.cpp
@@ -19,8 +19,8 @@
 
 #include "renamejob.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 
 #include "job_p.h"
 #include "message_p.h"
@@ -32,7 +32,7 @@ namespace KIMAP
   class RenameJobPrivate : public JobPrivate
   {
     public:
-      RenameJobPrivate( Session *session, const QString& name ) : JobPrivate(session, name) { }
+      RenameJobPrivate( Session *session, const QString& name ) : JobPrivate( session, name ) { }
       ~RenameJobPrivate() { }
 
       QString sourceMailBox;
@@ -43,7 +43,7 @@ namespace KIMAP
 using namespace KIMAP;
 
 RenameJob::RenameJob( Session *session )
-  : Job( *new RenameJobPrivate(session, i18n("Rename")) )
+  : Job( *new RenameJobPrivate( session, i18n( "Rename" ) ) )
 {
 }
 
@@ -53,33 +53,34 @@ RenameJob::~RenameJob()
 
 void RenameJob::doStart()
 {
-  Q_D(RenameJob);
-  d->tags << d->sessionInternal()->sendCommand( "RENAME", '\"' + KIMAP::encodeImapFolderName( d->sourceMailBox.toUtf8() ) + "\" \""
-                                              + KIMAP::encodeImapFolderName( d->destinationMailBox.toUtf8() )+ '\"' );
+  Q_D( RenameJob );
+  d->tags << d->sessionInternal()->sendCommand( "RENAME", '\"' + KIMAP::encodeImapFolderName( d->sourceMailBox.toUtf8() ) +
+                                                "\" \"" + KIMAP::encodeImapFolderName( d->destinationMailBox.toUtf8() ) + '\"' );
 }
 
 void RenameJob::setSourceMailBox( const QString &mailBox )
 {
-  Q_D(RenameJob);
+  Q_D( RenameJob );
   d->sourceMailBox = mailBox;
 }
 
 QString RenameJob::sourceMailBox() const
 {
-  Q_D(const RenameJob);
+  Q_D( const RenameJob );
   return d->sourceMailBox;
 }
 
 void RenameJob::setDestinationMailBox( const QString &mailBox )
 {
-  Q_D(RenameJob);
+  Q_D( RenameJob );
   d->destinationMailBox = mailBox;
 }
 
 QString RenameJob::destinationMailBox() const
 {
-  Q_D(const RenameJob);
+  Q_D( const RenameJob );
   return d->destinationMailBox;
 }
 
 #include "renamejob.moc"
+
diff --git a/kimap/renamejob.h b/kimap/renamejob.h
index 84ae96a..28949f5 100644
--- a/kimap/renamejob.h
+++ b/kimap/renamejob.h
@@ -32,7 +32,7 @@ class RenameJobPrivate;
 class KIMAP_EXPORT RenameJob : public Job
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(RenameJob)
+  Q_DECLARE_PRIVATE( RenameJob )
 
   friend class SessionPrivate;
 
diff --git a/kimap/rfccodecs.cpp b/kimap/rfccodecs.cpp
index f102514..04cc886 100644
--- a/kimap/rfccodecs.cpp
+++ b/kimap/rfccodecs.cpp
@@ -331,7 +331,7 @@ const QString KIMAP::decodeRFC2047String( const QString &str,
   }
 
   // FIXME get rid of the conversion?
-  QByteArray aStr = str.toAscii ();  // QString.length() means Unicode chars
+  QByteArray aStr = str.toLatin1 ();  // QString.length() means Unicode chars
   QByteArray result;
   char *pos, *beg, *end, *mid = 0;
   QByteArray cstr;
@@ -353,8 +353,9 @@ const QString KIMAP::decodeRFC2047String( const QString &str,
     for ( i = 2, pos += 2;
           i < maxLen &&
               ( *pos != '?' && ( ispunct( *pos ) || isalnum ( *pos ) ) );
-          i++ )
+          i++ ) {
       pos++;
+    }
     if ( *pos != '?' || i < 4 || i >= maxLen ) {
       valid = false;
     } else {
@@ -376,7 +377,7 @@ const QString KIMAP::decodeRFC2047String( const QString &str,
       }
       pos += 3;
       i += 3;
-//  qDebug() << "Charset:" << charset << "- Language:" << language << "-'" << pos << "'";
+//  kDebug() << "Charset:" << charset << "- Language:" << language << "-'" << pos << "'";
     }
     if ( valid ) {
       mid = pos;
@@ -401,10 +402,10 @@ const QString KIMAP::decodeRFC2047String( const QString &str,
             cstr[i] = ' ';
           }
         }
-//    qDebug() << "before QP '"
+//    kDebug() << "before QP '"
 //    << cstr << "'";
         cstr = KCodecs::quotedPrintableDecode( cstr );
-//    qDebug() << "after QP '"
+//    kDebug() << "after QP '"
 //    << cstr << "'";
       } else {
         // decode base64 text
@@ -418,7 +419,7 @@ const QString KIMAP::decodeRFC2047String( const QString &str,
 
       pos = end - 1;
     } else {
-//    qDebug() << "invalid";
+//    kDebug() << "invalid";
       //result += "=?";
       //pos = beg -1; // because pos gets increased shortly afterwards
       pos = beg - 2;
@@ -427,9 +428,9 @@ const QString KIMAP::decodeRFC2047String( const QString &str,
     }
   }
   if ( !charset.isEmpty () ) {
-    QTextCodec *aCodec = codecForName( charset.toAscii () );
+    QTextCodec *aCodec = codecForName( charset.toLatin1 () );
     if ( aCodec ) {
-//    qDebug() << "Codec is" << aCodec->name();
+//    kDebug() << "Codec is" << aCodec->name();
       return aCodec->toUnicode( result );
     }
   }
@@ -636,7 +637,7 @@ const QString KIMAP::decodeRFC2231String( const QString &str )
   QString st = str.mid ( l + 1 );
   QString language = str.mid ( p + 1, l - p - 1 );
 
-  //qDebug() << "Charset:" << charset << "Language:" << language;
+  //kDebug() << "Charset:" << charset << "Language:" << language;
 
   char ch, ch2;
   p = 0;
diff --git a/kimap/searchjob.cpp b/kimap/searchjob.cpp
index ede53a3..0e91010 100644
--- a/kimap/searchjob.cpp
+++ b/kimap/searchjob.cpp
@@ -19,8 +19,8 @@
 
 #include "searchjob.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 
 #include <QtCore/QDate>
 
@@ -35,7 +35,7 @@ namespace KIMAP
   class SearchJobPrivate : public JobPrivate
   {
     public:
-      SearchJobPrivate( Session *session, const QString& name ) : JobPrivate(session, name), logic(SearchJob::And) {
+      SearchJobPrivate( Session *session, const QString& name ) : JobPrivate( session, name ), logic( SearchJob::And ) {
         criteriaMap[SearchJob::All]  = "ALL";
         criteriaMap[SearchJob::Answered] = "ANSWERED";
         criteriaMap[SearchJob::BCC] = "BCC";
@@ -89,7 +89,6 @@ namespace KIMAP
       }
       ~SearchJobPrivate() { }
 
-
       QByteArray charset;
       QList<QByteArray> criterias;
       QMap<SearchJob::SearchCriteria, QByteArray > criteriaMap;
@@ -105,7 +104,7 @@ namespace KIMAP
 using namespace KIMAP;
 
 SearchJob::SearchJob( Session *session )
-  : Job( *new SearchJobPrivate(session, i18nc("Name of the search job", "Search")) )
+  : Job( *new SearchJobPrivate( session, i18nc( "Name of the search job", "Search" ) ) )
 {
 }
 
@@ -115,37 +114,41 @@ SearchJob::~SearchJob()
 
 void SearchJob::doStart()
 {
-  Q_D(SearchJob);
+  Q_D( SearchJob );
 
   QByteArray searchKey;
 
-  if (!d->charset.isEmpty()) {
+  if ( !d->charset.isEmpty() ) {
     searchKey = "CHARSET " + d->charset;
   }
 
-  if (d->logic == SearchJob::Not) {
-    searchKey += "NOT";
-  } else if (d->logic == SearchJob::Or) {
-    searchKey += "OR";
+  if ( d->logic == SearchJob::Not ) {
+    searchKey += "NOT ";
+  } else if ( d->logic == SearchJob::Or && d->criterias.size() > 1 ) {
+    searchKey += "OR ";
   }
 
   if ( d->logic == SearchJob::And ) {
-    for ( int i = 0; i<d->criterias.size(); i++ ) {
+    for ( int i = 0; i < d->criterias.size(); i++ ) {
       const QByteArray key = d->criterias.at( i );
-      if ( i>0 ) searchKey+= ' ';
+      if ( i > 0 ) {
+        searchKey += ' ';
+      }
       searchKey += key;
     }
   } else {
-    for ( int i = 0; i<d->criterias.size(); i++ ) {
+    for ( int i = 0; i < d->criterias.size(); i++ ) {
       const QByteArray key = d->criterias.at( i );
-      if ( i>0 ) searchKey+= ' ';
+      if ( i > 0 ) {
+        searchKey += ' ';
+      }
       searchKey += '(' + key + ')';
     }
   }
 
   QByteArray command = "SEARCH";
   if ( d->uidBased ) {
-    command = "UID "+ command;
+    command = "UID " + command;
   }
 
   d->tags << d->sessionInternal()->sendCommand( command, searchKey );
@@ -153,44 +156,43 @@ void SearchJob::doStart()
 
 void SearchJob::handleResponse( const Message &response )
 {
-  Q_D(SearchJob);
+  Q_D( SearchJob );
 
-  if (handleErrorReplies(response) == NotHandled ) {
+  if ( handleErrorReplies( response ) == NotHandled  ) {
     if ( response.content[0].toString() == "+" ) {
       d->sessionInternal()->sendData( d->contents[d->nextContent] );
       d->nextContent++;
     } else if ( response.content[1].toString() == "SEARCH" ) {
-      for(int i = 2; i < response.content.size(); i++) {
-        d->results.append(response.content[i].toString().toInt());
+      for ( int i = 2; i < response.content.size(); i++ ) {
+        d->results.append( response.content[i].toString().toInt() );
       }
     }
   }
 }
 
-
 void SearchJob::setCharset( const QByteArray &charset )
 {
-  Q_D(SearchJob);
+  Q_D( SearchJob );
   d->charset = charset;
 }
 
 QByteArray SearchJob::charset() const
 {
-  Q_D(const SearchJob);
+  Q_D( const SearchJob );
   return d->charset;
 }
 
 void SearchJob::setSearchLogic( SearchLogic logic )
 {
-  Q_D(SearchJob);
+  Q_D( SearchJob );
   d->logic = logic;
 }
 
 void SearchJob::addSearchCriteria( SearchCriteria criteria )
 {
-  Q_D(SearchJob);
+  Q_D( SearchJob );
 
-  switch (criteria) {
+  switch ( criteria ) {
     case All:
     case Answered:
     case Deleted:
@@ -205,36 +207,34 @@ void SearchJob::addSearchCriteria( SearchCriteria criteria )
     case Undraft:
     case Unflagged:
     case Unseen:
-      d->criterias.append(d->criteriaMap[criteria]);
+      d->criterias.append( d->criteriaMap[criteria] );
       break;
     default:
       //TODO Discuss if we keep error checking here, or accept anything, even if it is wrong
-      qDebug() << "Criteria " << d->criteriaMap[criteria] << " needs an argument, but none was specified.";
+      kDebug() << "Criteria " << d->criteriaMap[criteria] << " needs an argument, but none was specified.";
       break;
   }
 }
 
-
 void SearchJob::addSearchCriteria( SearchCriteria criteria, int argument )
 {
-  Q_D(SearchJob);
-  switch (criteria) {
+  Q_D( SearchJob );
+  switch ( criteria ) {
     case Larger:
     case Smaller:
-      d->criterias.append(d->criteriaMap[criteria] + ' ' + QByteArray::number(argument));
+      d->criterias.append( d->criteriaMap[criteria] + ' ' + QByteArray::number( argument ) );
       break;
     default:
       //TODO Discuss if we keep error checking here, or accept anything, even if it is wrong
-      qDebug() << "Criteria " << d->criteriaMap[criteria] << " doesn't accept an integer as an argument.";
+      kDebug() << "Criteria " << d->criteriaMap[criteria] << " doesn't accept an integer as an argument.";
       break;
   }
 }
 
-
 void SearchJob::addSearchCriteria( SearchCriteria criteria, const QByteArray &argument )
 {
-  Q_D(SearchJob);
-  switch (criteria) {
+  Q_D( SearchJob );
+  switch ( criteria ) {
     case BCC:
     case Body:
     case CC:
@@ -242,71 +242,71 @@ void SearchJob::addSearchCriteria( SearchCriteria criteria, const QByteArray &ar
     case Subject:
     case Text:
     case To:
-      d->contents.append(argument);
-      d->criterias.append(d->criteriaMap[criteria] + " {" + QByteArray::number(argument.size()) + '}');
+      d->contents.append( argument );
+      d->criterias.append( d->criteriaMap[criteria] + " {" + QByteArray::number( argument.size() ) + '}' );
       break;
     case Keyword:
     case Unkeyword:
     case Header:
     case Uid:
-      d->criterias.append(d->criteriaMap[criteria] + ' ' + argument);
+      d->criterias.append( d->criteriaMap[criteria] + ' ' + argument );
       break;
     default:
       //TODO Discuss if we keep error checking here, or accept anything, even if it is wrong
-      qDebug() << "Criteria " << d->criteriaMap[criteria] << " doesn't accept any argument.";
+      kDebug() << "Criteria " << d->criteriaMap[criteria] << " doesn't accept any argument.";
       break;
   }
 }
 
 void SearchJob::addSearchCriteria( SearchCriteria criteria, const QDate &argument )
 {
-  Q_D(SearchJob);
-  switch (criteria) {
+  Q_D( SearchJob );
+  switch ( criteria ) {
     case Before:
     case On:
     case SentBefore:
     case SentSince:
     case Since: {
-      QByteArray date = QByteArray::number(argument.day()) + '-';
+      QByteArray date = QByteArray::number( argument.day() ) + '-';
       date += d->months[argument.month()] + '-';
-      date += QByteArray::number(argument.year());
-      d->criterias.append(d->criteriaMap[criteria] + " \"" + date + '\"');
+      date += QByteArray::number( argument.year() );
+      d->criterias.append( d->criteriaMap[criteria] + " \"" + date + '\"' );
       break;
     }
     default:
       //TODO Discuss if we keep error checking here, or accept anything, even if it is wrong
-      qDebug() << "Criteria " << d->criteriaMap[criteria] << " doesn't accept a date as argument.";
+      kDebug() << "Criteria " << d->criteriaMap[criteria] << " doesn't accept a date as argument.";
       break;
   }
 }
 
 void SearchJob::addSearchCriteria( const QByteArray &searchCriteria )
 {
-  Q_D(SearchJob);
-  d->criterias.append(searchCriteria);
+  Q_D( SearchJob );
+  d->criterias.append( searchCriteria );
 }
 
 void SearchJob::setUidBased(bool uidBased)
 {
-  Q_D(SearchJob);
+  Q_D( SearchJob );
   d->uidBased = uidBased;
 }
 
 bool SearchJob::isUidBased() const
 {
-  Q_D(const SearchJob);
+  Q_D( const SearchJob );
   return d->uidBased;
 }
 
 QList<qint64> SearchJob::results() const
 {
-  Q_D(const SearchJob);
+  Q_D( const SearchJob );
   return d->results;
 }
 
 QList<int> SearchJob::foundItems()
 {
-  Q_D(const SearchJob);
+  Q_D( const SearchJob );
 
   QList<int> results;
   qCopy( d->results.begin(), d->results.end(), results.begin() );
@@ -314,4 +314,5 @@ QList<int> SearchJob::foundItems()
   return results;
 }
 
-#include "searchjob.moc"
\ No newline at end of file
+#include "searchjob.moc"
+
diff --git a/kimap/searchjob.h b/kimap/searchjob.h
index 077e8d4..1b53c1e 100644
--- a/kimap/searchjob.h
+++ b/kimap/searchjob.h
@@ -35,7 +35,7 @@ class SearchJobPrivate;
 class KIMAP_EXPORT SearchJob : public Job
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(SearchJob)
+  Q_DECLARE_PRIVATE( SearchJob )
 
   friend class SessionPrivate;
 
diff --git a/kimap/selectjob.cpp b/kimap/selectjob.cpp
index b18130d..bcc65c6 100644
--- a/kimap/selectjob.cpp
+++ b/kimap/selectjob.cpp
@@ -19,7 +19,8 @@
 
 #include "selectjob.h"
 
-#include <klocale.h>
+#include <KDE/KLocalizedString>
+#include <kdebug.h>
 
 #include "job_p.h"
 #include "message_p.h"
@@ -32,8 +33,8 @@ namespace KIMAP
   {
     public:
       SelectJobPrivate( Session *session, const QString& name )
-        : JobPrivate(session, name), readOnly(false), messageCount(-1), recentCount(-1),
-          firstUnseenIndex(-1), uidValidity(-1), nextUid(-1) { }
+        : JobPrivate( session, name ), readOnly( false ), messageCount( -1 ), recentCount( -1 ),
+          firstUnseenIndex( -1 ), uidValidity( -1 ), nextUid( -1 ) { }
       ~SelectJobPrivate() { }
 
       QString mailBox;
@@ -52,7 +53,7 @@ namespace KIMAP
 using namespace KIMAP;
 
 SelectJob::SelectJob( Session *session )
-  : Job( *new SelectJobPrivate(session, i18nc("name of the select job", "Select")) )
+  : Job( *new SelectJobPrivate( session, i18nc( "name of the select job", "Select" ) ) )
 {
 }
 
@@ -62,73 +63,73 @@ SelectJob::~SelectJob()
 
 void SelectJob::setMailBox( const QString &mailBox )
 {
-  Q_D(SelectJob);
+  Q_D( SelectJob );
   d->mailBox = mailBox;
 }
 
 QString SelectJob::mailBox() const
 {
-  Q_D(const SelectJob);
+  Q_D( const SelectJob );
   return d->mailBox;
 }
 
 void SelectJob::setOpenReadOnly( bool readOnly )
 {
-  Q_D(SelectJob);
+  Q_D( SelectJob );
   d->readOnly = readOnly;
 }
 
 bool SelectJob::isOpenReadOnly() const
 {
-  Q_D(const SelectJob);
+  Q_D( const SelectJob );
   return d->readOnly;
 }
 
 QList<QByteArray> SelectJob::flags() const
 {
-  Q_D(const SelectJob);
+  Q_D( const SelectJob );
   return d->flags;
 }
 
 QList<QByteArray> SelectJob::permanentFlags() const
 {
-  Q_D(const SelectJob);
+  Q_D( const SelectJob );
   return d->permanentFlags;
 }
 
 int SelectJob::messageCount() const
 {
-  Q_D(const SelectJob);
+  Q_D( const SelectJob );
   return d->messageCount;
 }
 
 int SelectJob::recentCount() const
 {
-  Q_D(const SelectJob);
+  Q_D( const SelectJob );
   return d->recentCount;
 }
 
 int SelectJob::firstUnseenIndex() const
 {
-  Q_D(const SelectJob);
+  Q_D( const SelectJob );
   return d->firstUnseenIndex;
 }
 
 qint64 SelectJob::uidValidity() const
 {
-  Q_D(const SelectJob);
+  Q_D( const SelectJob );
   return d->uidValidity;
 }
 
 qint64 SelectJob::nextUid() const
 {
-  Q_D(const SelectJob);
+  Q_D( const SelectJob );
   return d->nextUid;
 }
 
 void SelectJob::doStart()
 {
-  Q_D(SelectJob);
+  Q_D( SelectJob );
 
   QByteArray command = "SELECT";
   if ( d->readOnly ) {
@@ -140,56 +141,65 @@ void SelectJob::doStart()
 
 void SelectJob::handleResponse( const Message &response )
 {
-  Q_D(SelectJob);
+  Q_D( SelectJob );
 
-  if ( handleErrorReplies(response) == NotHandled) {
+  if ( handleErrorReplies( response ) == NotHandled ) {
       if ( response.content.size() >= 2 ) {
         QByteArray code = response.content[1].toString();
 
-        if ( code=="OK" ) {
-          if ( response.responseCode.size() < 2 ) return;
+        if ( code == "OK" ) {
+          if ( response.responseCode.size() < 2 ) {
+            return;
+          }
 
           code = response.responseCode[0].toString();
 
-          if ( code=="PERMANENTFLAGS" ) {
+          if ( code == "PERMANENTFLAGS" ) {
             d->permanentFlags = response.responseCode[1].toList();
           } else {
             bool isInt;
 
-            if ( code=="UIDVALIDITY" ) {
-              qint64 value = response.responseCode[1].toString().toLongLong(&isInt);
-              if ( !isInt ) return;
+            if ( code == "UIDVALIDITY" ) {
+              qint64 value = response.responseCode[1].toString().toLongLong( &isInt );
+              if ( !isInt ) {
+                return;
+              }
               d->uidValidity = value;
             } else {
-              qint64 value = response.responseCode[1].toString().toLongLong(&isInt);
-              if ( !isInt ) return;
-              if ( code=="UNSEEN" ) {
+              qint64 value = response.responseCode[1].toString().toLongLong( &isInt );
+              if ( !isInt ) {
+                return;
+              }
+              if ( code == "UNSEEN" ) {
                 d->firstUnseenIndex = value;
-              } else if ( code=="UIDNEXT" ) {
+              } else if ( code == "UIDNEXT" ) {
                 d->nextUid = value;
               }
             }
           }
-        } else if ( code=="FLAGS" ) {
+        } else if ( code == "FLAGS" ) {
           d->flags = response.content[2].toList();
         } else {
           bool isInt;
-          int value = response.content[1].toString().toInt(&isInt);
-          if ( !isInt || response.content.size()<3 ) return;
+          int value = response.content[1].toString().toInt( &isInt );
+          if ( !isInt || response.content.size() < 3 ) {
+            return;
+          }
 
           code = response.content[2].toString();
-          if ( code=="EXISTS" ) {
+          if ( code == "EXISTS" ) {
             d->messageCount = value;
-          } else if ( code=="RECENT" ) {
+          } else if ( code == "RECENT" ) {
             d->recentCount = value;
           }
         }
       } else {
-        qDebug("%s", response.toString().constData());
+        kDebug() << response.toString();
       }
   } else {
     Q_ASSERT( error() || d->m_session->selectedMailBox() == d->mailBox );
   }
 }
 
-#include "selectjob.moc"
\ No newline at end of file
+#include "selectjob.moc"
+
diff --git a/kimap/selectjob.h b/kimap/selectjob.h
index c67d28c..87157b5 100644
--- a/kimap/selectjob.h
+++ b/kimap/selectjob.h
@@ -33,7 +33,7 @@ class SelectJobPrivate;
 class KIMAP_EXPORT SelectJob : public Job
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(SelectJob)
+  Q_DECLARE_PRIVATE( SelectJob )
 
   friend class SessionPrivate;
 
diff --git a/kimap/session.cpp b/kimap/session.cpp
index 031508b..2b23adc 100644
--- a/kimap/session.cpp
+++ b/kimap/session.cpp
@@ -27,7 +27,8 @@
 #include <QtCore/QDebug>
 #include <QtCore/QTimer>
 
-#include <klocale.h>
+#include <KDebug>
+#include <KDE/KLocalizedString>
 
 #include "job.h"
 #include "loginjob.h"
@@ -36,14 +37,14 @@
 #include "sessionthread_p.h"
 #include "rfccodecs.h"
 
-Q_DECLARE_METATYPE(KTcpSocket::SslVersion)
-Q_DECLARE_METATYPE(QSslSocket::SslMode)
+Q_DECLARE_METATYPE( KTcpSocket::SslVersion )
+Q_DECLARE_METATYPE( QSslSocket::SslMode )
 static const int _kimap_sslVersionId = qRegisterMetaType<KTcpSocket::SslVersion>();
 
 using namespace KIMAP;
 
 Session::Session( const QString &hostName, quint16 port, QObject *parent)
-  : QObject(parent), d(new SessionPrivate(this))
+  : QObject( parent ), d( new SessionPrivate( this ) )
 {
   if ( !qgetenv( "KIMAP_LOGFILE" ).isEmpty() ) {
     d->logger = new SessionLogger;
@@ -53,13 +54,23 @@ Session::Session( const QString &hostName, quint16 port, QObject *parent)
   d->state = Disconnected;
   d->jobRunning = false;
 
-  d->thread = new SessionThread(hostName, port, this);
-  connect(d->thread, SIGNAL(encryptionNegotiationResult(bool,KTcpSocket::SslVersion)),
-          d, SLOT(onEncryptionNegotiationResult(bool,KTcpSocket::SslVersion)));
-  connect(d->thread, SIGNAL(sslError(KSslErrorUiData)), this, SLOT(handleSslError(KSslErrorUiData)));
+  d->thread = new SessionThread( hostName, port );
+  connect( d->thread, SIGNAL(encryptionNegotiationResult(bool,KTcpSocket::SslVersion)),
+           d, SLOT(onEncryptionNegotiationResult(bool,KTcpSocket::SslVersion)) );
+  connect( d->thread, SIGNAL(sslError(KSslErrorUiData)),
+           d, SLOT(handleSslError(KSslErrorUiData)) );
+  connect( d->thread, SIGNAL(socketDisconnected()),
+           d, SLOT(socketDisconnected()) );
+  connect( d->thread, SIGNAL(responseReceived(KIMAP::Message)),
+           d, SLOT(responseReceived(KIMAP::Message)) );
+  connect( d->thread, SIGNAL(socketConnected()),
+           d, SLOT(socketConnected()) );
+  connect( d->thread, SIGNAL(socketActivity()),
+           d, SLOT(socketActivity()) );
+  connect( d->thread, SIGNAL(socketError()),
+           d, SLOT(socketError()) );
 
   d->startSocketTimer();
-  d->thread->start();
 }
 
 Session::~Session()
@@ -114,22 +125,19 @@ void KIMAP::Session::close()
 
 void SessionPrivate::handleSslError(const KSslErrorUiData& errorData)
 {
-  if (uiProxy && uiProxy->ignoreSslError(errorData)) {
-    QMetaObject::invokeMethod( thread, "sslErrorHandlerResponse", Q_ARG(bool, true) );
-  } else {
-    QMetaObject::invokeMethod( thread, "sslErrorHandlerResponse", Q_ARG(bool, false) );
-  }
+  const bool ignoreSslError = uiProxy && uiProxy->ignoreSslError( errorData );
+  thread->sslErrorHandlerResponse(ignoreSslError);
 }
 
 SessionPrivate::SessionPrivate( Session *session )
   : QObject( session ),
-    q(session),
-    state(Session::Disconnected),
-    logger(0),
-    currentJob(0),
-    tagCount(0),
-    sslVersion(KTcpSocket::UnknownSslVersion),
-    socketTimerInterval(30000) // By default timeouts on 30s
+    q( session ),
+    state( Session::Disconnected ),
+    logger( 0 ),
+    currentJob( 0 ),
+    tagCount( 0 ),
+    sslVersion( KTcpSocket::UnknownSslVersion ),
+    socketTimerInterval( 30000 ) // By default timeouts on 30s
 {
 }
 
@@ -140,20 +148,20 @@ SessionPrivate::~SessionPrivate()
 
 void SessionPrivate::addJob(Job *job)
 {
-  queue.append(job);
+  queue.append( job );
   emit q->jobQueueSizeChanged( q->jobQueueSize() );
 
-  QObject::connect( job, SIGNAL(result(KJob*)), q, SLOT(jobDone(KJob*)) );
-  QObject::connect( job, SIGNAL(destroyed(QObject*)), q, SLOT(jobDestroyed(QObject*)) );
+  QObject::connect( job, SIGNAL(result(KJob*)), this, SLOT(jobDone(KJob*)) );
+  QObject::connect( job, SIGNAL(destroyed(QObject*)), this, SLOT(jobDestroyed(QObject*)) );
 
-  if ( state!=Session::Disconnected ) {
+  if ( state != Session::Disconnected ) {
     startNext();
   }
 }
 
 void SessionPrivate::startNext()
 {
-  QTimer::singleShot( 0, q, SLOT(doStartNext()) );
+  QMetaObject::invokeMethod( this, "doStartNext" );
 }
 
 void SessionPrivate::doStartNext()
@@ -190,13 +198,14 @@ void SessionPrivate::jobDone( KJob *job )
 void SessionPrivate::jobDestroyed( QObject *job )
 {
   queue.removeAll( static_cast<KIMAP::Job*>( job ) );
-  if ( currentJob == job )
+  if ( currentJob == job ) {
     currentJob = 0;
+  }
 }
 
 void SessionPrivate::responseReceived( const Message &response )
 {
-  if ( logger && ( state==Session::Authenticated || state==Session::Selected ) ) {
+  if ( logger && ( state == Session::Authenticated || state == Session::Selected ) ) {
     logger->dataReceived( response.toString() );
   }
 
@@ -213,11 +222,11 @@ void SessionPrivate::responseReceived( const Message &response )
 
   switch ( state ) {
   case Session::Disconnected:
-    if (socketTimer.isActive()) {
+    if ( socketTimer.isActive() ) {
       stopSocketTimer();
     }
-    if ( code=="OK" ) {
-      setState(Session::NotAuthenticated);
+    if ( code == "OK" ) {
+      setState( Session::NotAuthenticated );
 
       Message simplified = response;
       simplified.content.removeFirst(); // Strip the tag
@@ -225,8 +234,8 @@ void SessionPrivate::responseReceived( const Message &response )
       greeting = simplified.toString().trimmed(); // Save the server greeting
 
       startNext();
-    } else if ( code=="PREAUTH" ) {
-      setState(Session::Authenticated);
+    } else if ( code == "PREAUTH" ) {
+      setState( Session::Authenticated );
 
       Message simplified = response;
       simplified.content.removeFirst(); // Strip the tag
@@ -239,74 +248,79 @@ void SessionPrivate::responseReceived( const Message &response )
     }
     return;
   case Session::NotAuthenticated:
-    if ( code=="OK" && tag==authTag ) {
-      setState(Session::Authenticated);
+    if ( code == "OK" && tag == authTag ) {
+      setState( Session::Authenticated );
     }
     break;
   case Session::Authenticated:
-    if ( code=="OK" && tag==selectTag ) {
-      setState(Session::Selected);
+    if ( code == "OK" && tag == selectTag ) {
+      setState( Session::Selected );
       currentMailBox = upcomingMailBox;
     }
     break;
   case Session::Selected:
-    if ( ( code=="OK" && tag==closeTag )
-      || ( code!="OK" && tag==selectTag) ) {
-      setState(Session::Authenticated);
+    if ( ( code == "OK" && tag == closeTag ) ||
+         ( code != "OK" && tag == selectTag ) ) {
+      setState( Session::Authenticated );
       currentMailBox = QByteArray();
-    } else if ( code=="OK" && tag==selectTag ) {
+    } else if ( code == "OK" && tag == selectTag ) {
       currentMailBox = upcomingMailBox;
     }
     break;
   }
 
-  if (tag==authTag) authTag.clear();
-  if (tag==selectTag) selectTag.clear();
-  if (tag==closeTag) closeTag.clear();
+  if ( tag == authTag ) {
+    authTag.clear();
+  }
+  if ( tag == selectTag ) {
+    selectTag.clear();
+  }
+  if ( tag == closeTag ) {
+    closeTag.clear();
+  }
 
   // If a job is running forward it the response
-  if ( currentJob!=0 ) {
+  if ( currentJob != 0 ) {
     restartSocketTimer();
     currentJob->handleResponse( response );
   } else {
     qWarning() << "A message was received from the server with no job to handle it:"
                << response.toString()
-               << '('+response.toString().toHex()+')';
+               << '(' + response.toString().toHex() + ')';
   }
 }
 
 void SessionPrivate::setState(Session::State s)
 {
-  if (s != state) {
+  if ( s != state ) {
     Session::State oldState = state;
     state = s;
-    emit q->stateChanged(state, oldState);
+    emit q->stateChanged( state, oldState );
   }
 }
 
 QByteArray SessionPrivate::sendCommand( const QByteArray &command, const QByteArray &args )
 {
-  QByteArray tag = 'A' + QByteArray::number(++tagCount).rightJustified(6, '0');
+  QByteArray tag = 'A' + QByteArray::number( ++tagCount ).rightJustified( 6, '0' );
 
-  QByteArray payload = tag+' '+command;
+  QByteArray payload = tag + ' ' + command;
   if ( !args.isEmpty() ) {
-    payload+= ' '+args;
+    payload += ' ' + args;
   }
 
   sendData( payload );
 
-  if ( command=="LOGIN" || command=="AUTHENTICATE" ) {
+  if ( command == "LOGIN" || command == "AUTHENTICATE" ) {
     authTag = tag;
-  } else if ( command=="SELECT" || command=="EXAMINE" ) {
+  } else if ( command == "SELECT" || command == "EXAMINE" ) {
     selectTag = tag;
     upcomingMailBox = args;
     upcomingMailBox.remove( 0, 1 );
     upcomingMailBox.chop( 1 );
     upcomingMailBox = KIMAP::decodeImapFolderName( upcomingMailBox );
-  } else if ( command=="CLOSE" ) {
+  } else if ( command == "CLOSE" ) {
     closeTag = tag;
   }
-
   return tag;
 }
 
@@ -314,11 +328,11 @@ void SessionPrivate::sendData( const QByteArray &data )
 {
   restartSocketTimer();
 
-  if ( logger && ( state==Session::Authenticated || state==Session::Selected ) ) {
+  if ( logger && ( state == Session::Authenticated || state == Session::Selected ) ) {
     logger->dataSent( data );
   }
 
-  thread->sendData(data+"\r\n");
+  thread->sendData( data + "\r\n" );
 }
 
 void SessionPrivate::socketConnected()
@@ -330,10 +344,10 @@ void SessionPrivate::socketConnected()
   if ( !queue.isEmpty() ) {
     KIMAP::LoginJob *login = qobject_cast<KIMAP::LoginJob*>( queue.first() );
     if ( login ) {
-      willUseSsl = ( login->encryptionMode() == KIMAP::LoginJob::SslV2 )
-                || ( login->encryptionMode() == KIMAP::LoginJob::SslV3 )
-                || ( login->encryptionMode() == KIMAP::LoginJob::SslV3_1 )
-                || ( login->encryptionMode() == KIMAP::LoginJob::AnySslVersion );
+      willUseSsl = ( login->encryptionMode() == KIMAP::LoginJob::SslV2 ) ||
+                   ( login->encryptionMode() == KIMAP::LoginJob::SslV3 ) ||
+                   ( login->encryptionMode() == KIMAP::LoginJob::SslV3_1 ) ||
+                   ( login->encryptionMode() == KIMAP::LoginJob::AnySslVersion );
 
       userName = login->userName();
     }
@@ -348,16 +362,16 @@ void SessionPrivate::socketConnected()
 
 void SessionPrivate::socketDisconnected()
 {
-  if (socketTimer.isActive()) {
+  if ( socketTimer.isActive() ) {
     stopSocketTimer();
   }
 
-  if ( logger && ( state==Session::Authenticated || state==Session::Selected ) ) {
+  if ( logger && ( state == Session::Authenticated || state == Session::Selected ) ) {
     logger->disconnectionOccured();
   }
 
   if ( state != Session::Disconnected ) {
-    setState(Session::Disconnected);
+    setState( Session::Disconnected );
     emit q->connectionLost();
   } else {
     emit q->connectionFailed();
@@ -375,7 +389,7 @@ void SessionPrivate::socketActivity()
 
 void SessionPrivate::socketError()
 {
-  if (socketTimer.isActive()) {
+  if ( socketTimer.isActive() ) {
     stopSocketTimer();
   }
 
@@ -397,14 +411,15 @@ void SessionPrivate::clearJobQueue()
     currentJob->connectionLost();
   }
 
-  qDeleteAll(queue);
+  QQueue<Job*> queueCopy = queue; // copy because jobDestroyed calls removeAll
+  qDeleteAll(queueCopy);
   queue.clear();
   emit q->jobQueueSizeChanged( 0 );
 }
 
 void SessionPrivate::startSsl(const KTcpSocket::SslVersion &version)
 {
-  QMetaObject::invokeMethod( thread, "startSsl", Qt::QueuedConnection, Q_ARG(KTcpSocket::SslVersion, version) );
+  thread->startSsl( version );
 }
 
 QString Session::selectedMailBox() const
@@ -449,7 +464,7 @@ int SessionPrivate::socketTimeout() const
 
 void SessionPrivate::startSocketTimer()
 {
-  if ( socketTimerInterval<0 ) {
+  if ( socketTimerInterval < 0 ) {
     return;
   }
   Q_ASSERT( !socketTimer.isActive() );
@@ -463,7 +478,7 @@ void SessionPrivate::startSocketTimer()
 
 void SessionPrivate::stopSocketTimer()
 {
-  if ( socketTimerInterval<0 ) {
+  if ( socketTimerInterval < 0 ) {
     return;
   }
 
@@ -483,7 +498,7 @@ void SessionPrivate::restartSocketTimer()
 
 void SessionPrivate::onSocketTimeout()
 {
-  qDebug() << "Socket timeout!";
+  kDebug() << "Socket timeout!";
   thread->closeSocket();
 }
 
@@ -494,3 +509,4 @@ void Session::setTimeout( int timeout )
 
 #include "session.moc"
 #include "session_p.moc"
+
diff --git a/kimap/session.h b/kimap/session.h
index e23fbc4..b745246 100644
--- a/kimap/session.h
+++ b/kimap/session.h
@@ -37,7 +37,7 @@ struct Message;
 class KIMAP_EXPORT Session : public QObject
 {
   Q_OBJECT
-  Q_ENUMS(State)
+  Q_ENUMS( State )
 
   friend class JobPrivate;
 
@@ -135,18 +135,6 @@ class KIMAP_EXPORT Session : public QObject
     void stateChanged(KIMAP::Session::State newState, KIMAP::Session::State oldState);
 
   private:
-    Q_PRIVATE_SLOT( d, void doStartNext() )
-    Q_PRIVATE_SLOT( d, void jobDone( KJob* ) )
-    Q_PRIVATE_SLOT( d, void jobDestroyed( QObject* ) )
-    Q_PRIVATE_SLOT( d, void responseReceived( const KIMAP::Message& ) )
-
-    Q_PRIVATE_SLOT( d, void socketConnected() )
-    Q_PRIVATE_SLOT( d, void socketDisconnected() )
-    Q_PRIVATE_SLOT( d, void socketError() )
-    Q_PRIVATE_SLOT( d, void socketActivity() )
-
-    Q_PRIVATE_SLOT( d, void handleSslError( const KSslErrorUiData &errorData ) )
-
     friend class SessionPrivate;
     SessionPrivate *const d;
 };
diff --git a/kimap/session_p.h b/kimap/session_p.h
index 37bfd57..fd5101b 100644
--- a/kimap/session_p.h
+++ b/kimap/session_p.h
@@ -46,7 +46,7 @@ class KIMAP_EXPORT SessionPrivate : public QObject
   friend class Session;
 
   public:
-    SessionPrivate( Session *session );
+    explicit SessionPrivate( Session *session );
     virtual ~SessionPrivate();
 
     void addJob(Job *job);
@@ -54,8 +54,6 @@ class KIMAP_EXPORT SessionPrivate : public QObject
     void startSsl(const KTcpSocket::SslVersion &version);
     void sendData( const QByteArray &data );
 
-    void handleSslError( const KSslErrorUiData &errorData );
-
     KTcpSocket::SslVersion negotiatedEncryption() const;
 
     void setSocketTimeout( int ms );
@@ -68,20 +66,23 @@ class KIMAP_EXPORT SessionPrivate : public QObject
     void onEncryptionNegotiationResult(bool isEncrypted, KTcpSocket::SslVersion sslVersion);
     void onSocketTimeout();
 
-  private:
-    void startNext();
     void doStartNext();
-    void jobDone( KJob *job );
-    void jobDestroyed( QObject *job );
-    void clearJobQueue();
-    void responseReceived( const KIMAP::Message &response );
-    void setState(Session::State state);
+    void jobDone( KJob* );
+    void jobDestroyed( QObject* );
+    void responseReceived( const KIMAP::Message& );
 
     void socketConnected();
     void socketDisconnected();
     void socketError();
     void socketActivity();
 
+    void handleSslError( const KSslErrorUiData &errorData );
+
+  private:
+    void startNext();
+    void clearJobQueue();
+    void setState(Session::State state);
+
     void startSocketTimer();
     void stopSocketTimer();
     void restartSocketTimer();
diff --git a/kimap/sessionlogger.cpp b/kimap/sessionlogger.cpp
index 715a5da..2c4bd07 100644
--- a/kimap/sessionlogger.cpp
+++ b/kimap/sessionlogger.cpp
@@ -20,6 +20,8 @@
 
 #include "sessionlogger_p.h"
 
+#include <KDebug>
+
 #include <unistd.h>
 
 using namespace KIMAP;
@@ -33,7 +35,9 @@ SessionLogger::SessionLogger()
   m_file.setFileName( qgetenv( "KIMAP_LOGFILE" )
                     + '.' + QString::number( getpid() )
                     + '.' + QString::number( m_id ) );
-  m_file.open( QFile::WriteOnly );
+  if (!m_file.open( QFile::WriteOnly )) {
+     kDebug()<<" m_file can be open in write only";
+  }
 }
 
 SessionLogger::~SessionLogger()
@@ -57,6 +61,3 @@ void SessionLogger::disconnectionOccured()
 {
   m_file.write( "X\n" );
 }
-
-
-
diff --git a/kimap/sessionthread.cpp b/kimap/sessionthread.cpp
index b7a1cb9..36e2c83 100644
--- a/kimap/sessionthread.cpp
+++ b/kimap/sessionthread.cpp
@@ -20,65 +20,73 @@
 #include "sessionthread_p.h"
 
 #include <QtCore/QDebug>
-#include <QtCore/QTimer>
+#include <QtCore/QThread>
 
-#include <kdebug.h>
+#include <KDE/KDebug>
 
 #include "imapstreamparser.h"
 #include "message_p.h"
-#include "session.h"
 
 using namespace KIMAP;
 
-Q_DECLARE_METATYPE(KTcpSocket::Error)
-Q_DECLARE_METATYPE(KSslErrorUiData)
+Q_DECLARE_METATYPE( KTcpSocket::Error )
+Q_DECLARE_METATYPE( KSslErrorUiData )
 static const int _kimap_socketErrorTypeId = qRegisterMetaType<KTcpSocket::Error>();
 static const int _kimap_sslErrorUiData = qRegisterMetaType<KSslErrorUiData>();
 
-SessionThread::SessionThread( const QString &hostName, quint16 port, Session *parent )
-  : QThread(), m_hostName(hostName), m_port(port),
-    m_session(parent), m_socket(0), m_stream(0), m_encryptedMode(false)
+SessionThread::SessionThread( const QString &hostName, quint16 port )
+  : QObject(), m_hostName( hostName ), m_port( port ),
+    m_socket( 0 ), m_stream( 0 ), m_mutex(),
+    m_encryptedMode( false ),
+    triedSslVersions( 0 ), doSslFallback( false )
 {
-  // Yeah, sounds weird, but QThread object is linked to the parent
-  // thread not to itself, and I'm too lazy to introduce yet another
-  // internal QObject
-  moveToThread(this);
+  // Just like the Qt docs now recommend, for event-driven threads:
+  // don't derive from QThread, create one directly and move the object to it.
+  QThread* thread = new QThread();
+  moveToThread( thread );
+  thread->start();
+  QMetaObject::invokeMethod( this, "threadInit" );
 }
 
 SessionThread::~SessionThread()
 {
-  // don't call quit() directly, this will deadlock in wait() if exec() hasn't run yet
-  QMetaObject::invokeMethod( this, "quit" );
-  if ( !wait( 10 * 1000 ) ) {
+  QMetaObject::invokeMethod( this, "threadQuit" );
+  if ( !thread()->wait( 10 * 1000 ) ) {
     kWarning() << "Session thread refuses to die, killing harder...";
-    terminate();
+    thread()->terminate();
     // Make sure to wait until it's done, otherwise it can crash when the pthread callback is called
-    wait();
+    thread()->wait();
   }
+  delete thread();
 }
 
+// Called in primary thread
 void SessionThread::sendData( const QByteArray &payload )
 {
-  QMutexLocker locker(&m_mutex);
+  QMutexLocker locker( &m_mutex );
 
   m_dataQueue.enqueue( payload );
-  QTimer::singleShot( 0, this, SLOT(writeDataQueue()) );
+  QMetaObject::invokeMethod( this, "writeDataQueue" );
 }
 
+// Called in secondary thread
 void SessionThread::writeDataQueue()
 {
-  QMutexLocker locker(&m_mutex);
+  Q_ASSERT( QThread::currentThread() == thread() );
+  if ( !m_socket )
+    return;
+  QMutexLocker locker( &m_mutex );
 
   while ( !m_dataQueue.isEmpty() ) {
     m_socket->write( m_dataQueue.dequeue() );
   }
 }
 
+// Called in secondary thread
 void SessionThread::readMessage()
 {
-  QMutexLocker locker(&m_mutex);
-
-  if ( m_stream->availableDataSize()==0 ) {
+  Q_ASSERT( QThread::currentThread() == thread() );
+  if ( !m_stream || m_stream->availableDataSize() == 0 ) {
     return;
   }
 
@@ -92,10 +100,10 @@ void SessionThread::readMessage()
         if ( string == "NIL" ) {
           *payload << Message::Part( QList<QByteArray>() );
         } else {
-          *payload << Message::Part(string);
+          *payload << Message::Part( string );
         }
       } else if ( m_stream->hasList() ) {
-        *payload << Message::Part(m_stream->readParenthesizedList());
+        *payload << Message::Part( m_stream->readParenthesizedList() );
       } else if ( m_stream->hasResponseCode() ) {
         payload = &message.responseCode;
       } else if ( m_stream->atResponseCodeEnd() ) {
@@ -103,128 +111,213 @@ void SessionThread::readMessage()
       } else if ( m_stream->hasLiteral() ) {
         QByteArray literal;
         while ( !m_stream->atLiteralEnd() ) {
-          literal+= m_stream->readLiteralPart();
+          literal += m_stream->readLiteralPart();
         }
-        *payload << Message::Part(literal);
+        *payload << Message::Part( literal );
       } else {
-        // Oops! Something really bad happened
-        throw ImapParserException( "Inconsistent state, probably due to some packet loss" );
+        // Oops! Something really bad happened, we won't be able to recover
+        // so close the socket immediately
+        qWarning( "Inconsistent state, probably due to some packet loss" );
+        doCloseSocket();
+        return;
       }
     }
 
-    emit responseReceived(message);
+    emit responseReceived( message );
 
-  } catch (KIMAP::ImapParserException e) {
+  } catch ( KIMAP::ImapParserException e ) {
     qWarning() << "The stream parser raised an exception:" << e.what();
   }
 
-  if ( m_stream->availableDataSize()>1 ) {
-    QTimer::singleShot( 0, this, SLOT(readMessage()) );
+  if ( m_stream->availableDataSize() > 1 ) {
+    QMetaObject::invokeMethod( this, "readMessage", Qt::QueuedConnection );
   }
 
 }
 
+// Called in main thread
 void SessionThread::closeSocket()
 {
-  QTimer::singleShot( 0, this, SLOT(doCloseSocket()) );
+  QMetaObject::invokeMethod( this, "doCloseSocket", Qt::QueuedConnection );
 }
 
+// Called in secondary thread
 void SessionThread::doCloseSocket()
 {
+  Q_ASSERT( QThread::currentThread() == thread() );
+  if ( !m_socket )
+    return;
   m_encryptedMode = false;
+  kDebug() << "close";
   m_socket->close();
 }
 
+// Called in secondary thread
 void SessionThread::reconnect()
 {
-  QMutexLocker locker(&m_mutex);
-
+  Q_ASSERT( QThread::currentThread() == thread() );
+  if ( m_socket == 0 ) // threadQuit already called
+    return;
   if ( m_socket->state() != SessionSocket::ConnectedState &&
        m_socket->state() != SessionSocket::ConnectingState ) {
-    if (m_encryptedMode) {
-      m_socket->connectToHostEncrypted(m_hostName, m_port);
+    if ( m_encryptedMode ) {
+      kDebug() << "connectToHostEncrypted" << m_hostName << m_port;
+      m_socket->connectToHostEncrypted( m_hostName, m_port );
     } else {
-      m_socket->connectToHost(m_hostName, m_port);
+      kDebug() << "connectToHost" << m_hostName << m_port;
+      m_socket->connectToHost( m_hostName, m_port );
     }
   }
 }
 
-void SessionThread::run()
+// Called in secondary thread
+void SessionThread::threadInit()
 {
+  Q_ASSERT( QThread::currentThread() == thread() );
   m_socket = new SessionSocket;
   m_stream = new ImapStreamParser( m_socket );
   connect( m_socket, SIGNAL(readyRead()),
            this, SLOT(readMessage()), Qt::QueuedConnection );
 
+  // Delay the call to slotSocketDisconnected so that it finishes disconnecting before we call reconnect()
   connect( m_socket, SIGNAL(disconnected()),
-           m_session, SLOT(socketDisconnected()) );
+           this, SLOT(slotSocketDisconnected()), Qt::QueuedConnection );
   connect( m_socket, SIGNAL(connected()),
-           m_session, SLOT(socketConnected()) );
+           this, SIGNAL(socketConnected()) );
   connect( m_socket, SIGNAL(error(KTcpSocket::Error)),
-           m_session, SLOT(socketError()) );
+           this, SLOT(socketError(KTcpSocket::Error)) );
   connect( m_socket, SIGNAL(bytesWritten(qint64)),
-           m_session, SLOT(socketActivity()) );
-  if ( m_socket->metaObject()->indexOfSignal("encryptedBytesWritten(qint64)" ) > -1 ) {
+           this, SIGNAL(socketActivity()) );
+  if ( m_socket->metaObject()->indexOfSignal( "encryptedBytesWritten(qint64)" ) > -1 ) {
       connect( m_socket, SIGNAL(encryptedBytesWritten(qint64)), // needs kdelibs > 4.8
-               m_session, SLOT(socketActivity()) );
+               this, SIGNAL(socketActivity()) );
   }
   connect( m_socket, SIGNAL(readyRead()),
-           m_session, SLOT(socketActivity()) );
-
-  connect( this, SIGNAL(responseReceived(KIMAP::Message)),
-           m_session, SLOT(responseReceived(KIMAP::Message)) );
+           this, SIGNAL(socketActivity()) );
 
-  QTimer::singleShot( 0, this, SLOT(reconnect()) );
-  exec();
+  QMetaObject::invokeMethod(this, "reconnect", Qt::QueuedConnection);
+}
 
+// Called in secondary thread
+void SessionThread::threadQuit()
+{
+  Q_ASSERT( QThread::currentThread() == thread() );
   delete m_stream;
+  m_stream = 0;
   delete m_socket;
+  m_socket = 0;
+  thread()->quit();
 }
 
-void SessionThread::startSsl(const KTcpSocket::SslVersion &version)
+// Called in primary thread
+void SessionThread::startSsl( KTcpSocket::SslVersion version )
 {
-  QMutexLocker locker(&m_mutex);
+  QMetaObject::invokeMethod( this, "doStartSsl", Q_ARG(KTcpSocket::SslVersion, version) );
+}
+
+// Called in secondary thread (via invokeMethod)
+void SessionThread::doStartSsl( KTcpSocket::SslVersion version )
+{
+  Q_ASSERT( QThread::currentThread() == thread() );
+  if ( !m_socket )
+    return;
+  if ( version == KTcpSocket::AnySslVersion ) {
+    doSslFallback = true;
+    if ( m_socket->advertisedSslVersion() == KTcpSocket::UnknownSslVersion ) {
+      m_socket->setAdvertisedSslVersion( KTcpSocket::AnySslVersion );
+    } else if ( !( triedSslVersions & KTcpSocket::TlsV1 ) ) {
+      triedSslVersions |= KTcpSocket::TlsV1;
+      m_socket->setAdvertisedSslVersion( KTcpSocket::TlsV1 );
+    } else if ( !( triedSslVersions & KTcpSocket::SslV3 ) ) {
+      triedSslVersions |= KTcpSocket::SslV3;
+      m_socket->setAdvertisedSslVersion( KTcpSocket::SslV3 );
+    } else if ( !( triedSslVersions & KTcpSocket::SslV2 ) ) {
+      triedSslVersions |= KTcpSocket::SslV2;
+      m_socket->setAdvertisedSslVersion( KTcpSocket::SslV2 );
+      doSslFallback = false;
+    }
+  } else {
+    m_socket->setAdvertisedSslVersion( version );
+  }
 
-  m_socket->setAdvertisedSslVersion(version);
   m_socket->ignoreSslErrors();
-  connect(m_socket, SIGNAL(encrypted()), this, SLOT(sslConnected()));
+  connect( m_socket, SIGNAL(encrypted()), this, SLOT(sslConnected()) );
   m_socket->startClientEncryption();
 }
 
+// Called in secondary thread
+void SessionThread::slotSocketDisconnected()
+{
+  Q_ASSERT( QThread::currentThread() == thread() );
+  if ( doSslFallback ) {
+    reconnect();
+  } else {
+    emit socketDisconnected();
+  }
+}
+
+// Called in secondary thread
+void SessionThread::socketError(KTcpSocket::Error error)
+{
+  Q_ASSERT( QThread::currentThread() == thread() );
+  if ( !m_socket )
+    return;
+  Q_UNUSED( error ); // can be used for debugging
+  if ( doSslFallback ) {
+    //do not call m_socket->disconnectFromHost() here, as that can trigger an error again (resulting in an endless loop).
+    m_socket->abort();
+  } else {
+    emit socketError();
+  }
+}
+
+// Called in secondary thread
 void SessionThread::sslConnected()
 {
-  QMutexLocker locker(&m_mutex);
+  Q_ASSERT( QThread::currentThread() == thread() );
+  if ( !m_socket )
+    return;
   KSslCipher cipher = m_socket->sessionCipher();
 
-  if ( m_socket->sslErrors().count() > 0 || m_socket->encryptionMode() != KTcpSocket::SslClientMode
-      || cipher.isNull() || cipher.usedBits() == 0) {
-      qDebug() << "Initial SSL handshake failed. cipher.isNull() is" << cipher.isNull()
-                    << ", cipher.usedBits() is" << cipher.usedBits()
-                    << ", the socket says:" <<  m_socket->errorString()
-                    << "and the list of SSL errors contains"
-                    << m_socket->sslErrors().count() << "items.";
-     KSslErrorUiData errorData(m_socket);
-     emit sslError(errorData);
+  if ( m_socket->sslErrors().count() > 0 ||
+       m_socket->encryptionMode() != KTcpSocket::SslClientMode ||
+       cipher.isNull() || cipher.usedBits() == 0 ) {
+     kDebug() << "Initial SSL handshake failed. cipher.isNull() is" << cipher.isNull()
+              << ", cipher.usedBits() is" << cipher.usedBits()
+              << ", the socket says:" <<  m_socket->errorString()
+              << "and the list of SSL errors contains"
+              << m_socket->sslErrors().count() << "items.";
+     KSslErrorUiData errorData( m_socket );
+     emit sslError( errorData );
   } else {
-    qDebug() << "TLS negotiation done.";
+    doSslFallback = false;
+    kDebug() << "TLS negotiation done.";
     m_encryptedMode = true;
-    emit encryptionNegotiationResult(true, m_socket->negotiatedSslVersion());
+    emit encryptionNegotiationResult( true, m_socket->negotiatedSslVersion() );
   }
 }
 
 void SessionThread::sslErrorHandlerResponse(bool response)
 {
-  QMutexLocker locker(&m_mutex);
-  if (response) {
+  QMetaObject::invokeMethod(this, "doSslErrorHandlerResponse", Q_ARG(bool, response));
+}
+
+// Called in secondary thread (via invokeMethod)
+void SessionThread::doSslErrorHandlerResponse(bool response)
+{
+  Q_ASSERT( QThread::currentThread() == thread() );
+  if ( !m_socket )
+    return;
+  if ( response ) {
     m_encryptedMode = true;
-    emit encryptionNegotiationResult(true, m_socket->negotiatedSslVersion());
+    emit encryptionNegotiationResult( true, m_socket->negotiatedSslVersion() );
   } else {
      m_encryptedMode = false;
      //reconnect in unencrypted mode, so new commands can be issued
      m_socket->disconnectFromHost();
      m_socket->waitForDisconnected();
-     m_socket->connectToHost(m_hostName, m_port);
-     emit encryptionNegotiationResult(false, KTcpSocket::UnknownSslVersion);
+     m_socket->connectToHost( m_hostName, m_port );
+     emit encryptionNegotiationResult( false, KTcpSocket::UnknownSslVersion );
   }
 }
 
diff --git a/kimap/sessionthread_p.h b/kimap/sessionthread_p.h
index 672c418..47a94fb 100644
--- a/kimap/sessionthread_p.h
+++ b/kimap/sessionthread_p.h
@@ -22,7 +22,6 @@
 
 #include <QtCore/QMutex>
 #include <QtCore/QQueue>
-#include <QtCore/QThread>
 
 #include <ktcpsocket.h>
 
@@ -32,52 +31,62 @@ namespace KIMAP {
 
 class ImapStreamParser;
 struct Message;
-class Session;
 
-class SessionThread : public QThread
+class SessionThread : public QObject
 {
   Q_OBJECT
 
   public:
-    explicit SessionThread( const QString &hostName, quint16 port, Session *parent );
+    explicit SessionThread( const QString &hostName, quint16 port );
     ~SessionThread();
 
     inline QString hostName() { return m_hostName; }
     inline quint16 port() { return m_port; }
 
     void sendData( const QByteArray &payload );
-    void run();
 
   public slots:
     void closeSocket();
-    void reconnect();
-    void startSsl(const KTcpSocket::SslVersion &version);
+    void startSsl(KTcpSocket::SslVersion version);
+    void sslErrorHandlerResponse(bool result);
 
   signals:
+    void socketConnected();
+    void socketDisconnected();
+    void socketActivity();
+    void socketError();
     void responseReceived(const KIMAP::Message &response);
     void encryptionNegotiationResult(bool, KTcpSocket::SslVersion);
     void sslError(const KSslErrorUiData&);
 
   private slots:
+    void reconnect();
+    void threadInit();
+    void threadQuit();
     void readMessage();
     void writeDataQueue();
     void sslConnected();
-    void sslErrorHandlerResponse(bool result);
     void doCloseSocket();
+    void socketError(KTcpSocket::Error);
+    void slotSocketDisconnected();
+    void doStartSsl(KTcpSocket::SslVersion);
+    void doSslErrorHandlerResponse(bool result);
 
   private:
     QString m_hostName;
     quint16 m_port;
 
-    Session *m_session;
     SessionSocket *m_socket;
     ImapStreamParser *m_stream;
 
     QQueue<QByteArray> m_dataQueue;
 
+    // Protects m_dataQueue
     QMutex m_mutex;
 
     bool m_encryptedMode;
+    KTcpSocket::SslVersions triedSslVersions;
+    bool doSslFallback;
 };
 
 }
diff --git a/kimap/setacljob.cpp b/kimap/setacljob.cpp
index dea3d81..bb3841d 100644
--- a/kimap/setacljob.cpp
+++ b/kimap/setacljob.cpp
@@ -19,8 +19,8 @@
 
 #include "setacljob.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 
 #include "acljobbase_p.h"
 #include "message_p.h"
@@ -32,7 +32,7 @@ namespace KIMAP
   class SetAclJobPrivate : public AclJobBasePrivate
   {
     public:
-      SetAclJobPrivate( Session *session, const QString& name ) : AclJobBasePrivate(session, name) {}
+      SetAclJobPrivate( Session *session, const QString& name ) : AclJobBasePrivate( session, name ) {}
       ~SetAclJobPrivate() { }
   };
 }
@@ -40,9 +40,8 @@ namespace KIMAP
 using namespace KIMAP;
 
 SetAclJob::SetAclJob( Session *session )
-  : AclJobBase(*new SetAclJobPrivate(session, i18n("SetAcl")))
+  : AclJobBase( *new SetAclJobPrivate( session, i18n( "SetAcl" ) ) )
 {
-
 }
 
 SetAclJob::~SetAclJob()
@@ -51,32 +50,33 @@ SetAclJob::~SetAclJob()
 
 void SetAclJob::doStart()
 {
-  Q_D(SetAclJob);
+  Q_D( SetAclJob );
   QByteArray r = Acl::rightsToString( d->rightList );
-  if (d->modifier == Add) {
-    r.prepend('+');
-  } else if (d->modifier == Remove) {
-    r.prepend('-');
+  if ( d->modifier == Add ) {
+    r.prepend( '+' );
+  } else if ( d->modifier == Remove ) {
+    r.prepend( '-' );
   }
-  d->tags << d->sessionInternal()->sendCommand( "SETACL", '\"' + KIMAP::encodeImapFolderName( d->mailBox.toUtf8() ) + "\" \"" + d->id + "\" \"" + r +'\"');
+  d->tags << d->sessionInternal()->sendCommand( "SETACL", '\"' + KIMAP::encodeImapFolderName( d->mailBox.toUtf8() ) + "\" \"" + d->id + "\" \"" + r + '\"' );
 }
 
 void SetAclJob::setRights(AclModifier modifier, Acl::Rights rights)
 {
-  Q_D(SetAclJob);
-  d->setRights(modifier, rights);
+  Q_D( SetAclJob );
+  d->setRights( modifier, rights );
 }
 
 void SetAclJob::setIdentifier( const QByteArray &identifier )
 {
-  Q_D(SetAclJob);
-  d->setIdentifier(identifier);
+  Q_D( SetAclJob );
+  d->setIdentifier( identifier );
 }
 
 QByteArray SetAclJob::identifier()
 {
-  Q_D(SetAclJob);
+  Q_D( SetAclJob );
   return d->identifier();
 }
 
 #include "setacljob.moc"
+
diff --git a/kimap/setacljob.h b/kimap/setacljob.h
index 33df18d..c2496c3 100644
--- a/kimap/setacljob.h
+++ b/kimap/setacljob.h
@@ -30,7 +30,6 @@ class Session;
 struct Message;
 class SetAclJobPrivate;
 
-
 /**
  * Sets the rights that correspond to an identifier on a mailbox
  *
@@ -44,7 +43,7 @@ class SetAclJobPrivate;
 class KIMAP_EXPORT SetAclJob : public AclJobBase
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(SetAclJob)
+  Q_DECLARE_PRIVATE( SetAclJob )
 
   friend class SessionPrivate;
 
@@ -96,6 +95,7 @@ class KIMAP_EXPORT SetAclJob : public AclJobBase
      * Note that negative rights override positive rights: if
      * "fred" and "-fred" are both assigned the 'w' right, the
      * user "fred" will not have the 'w' right.
+     * @param identifier the identifier to set
      */
     void setIdentifier( const QByteArray &identifier );
     /**
diff --git a/kimap/setmetadatajob.cpp b/kimap/setmetadatajob.cpp
index c279812..80e46f9 100644
--- a/kimap/setmetadatajob.cpp
+++ b/kimap/setmetadatajob.cpp
@@ -19,8 +19,8 @@
 
 #include "setmetadatajob.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 
 #include "metadatajobbase_p.h"
 #include "message_p.h"
@@ -32,7 +32,7 @@ namespace KIMAP
   class SetMetaDataJobPrivate : public MetaDataJobBasePrivate
   {
     public:
-      SetMetaDataJobPrivate( Session *session, const QString& name ) : MetaDataJobBasePrivate(session, name), metaDataErrors(0), maxAcceptedSize(-1) { }
+      SetMetaDataJobPrivate( Session *session, const QString& name ) : MetaDataJobBasePrivate( session, name ), metaDataErrors( 0 ), maxAcceptedSize( -1 ) { }
       ~SetMetaDataJobPrivate() { }
 
       QMap<QByteArray, QByteArray> entries;
@@ -46,7 +46,7 @@ namespace KIMAP
 using namespace KIMAP;
 
 SetMetaDataJob::SetMetaDataJob( Session *session )
-  : MetaDataJobBase( *new SetMetaDataJobPrivate(session, i18n("SetMetaData")) )
+  : MetaDataJobBase( *new SetMetaDataJobPrivate( session, i18n( "SetMetaData" ) ) )
 {
 }
 
@@ -56,99 +56,102 @@ SetMetaDataJob::~SetMetaDataJob()
 
 void SetMetaDataJob::doStart()
 {
-  Q_D(SetMetaDataJob);
+  Q_D( SetMetaDataJob );
   QByteArray parameters;
   parameters = '\"' + KIMAP::encodeImapFolderName( d->mailBox.toUtf8() ) + "\" ";
   d->entriesIt = d->entries.constBegin();
 
   QByteArray command = "SETMETADATA";
-  if (d->serverCapability == Annotatemore) {
+  if ( d->serverCapability == Annotatemore ) {
     command = "SETANNOTATION";
     parameters += '\"' + d->entryName + "\" (";
-    d->m_name = i18n("SetAnnotation");
-    if (!d->entries.isEmpty()) {
-      for (; d->entriesIt != d->entries.constEnd(); ++d->entriesIt) {
-        parameters  += '\"' + d->entriesIt.key() + "\" \"" + d->entriesIt.value() + "\" ";
+    d->m_name = i18n( "SetAnnotation" );
+    if ( !d->entries.isEmpty() ) {
+      for ( ; d->entriesIt != d->entries.constEnd(); ++d->entriesIt ) {
+        parameters += '\"' + d->entriesIt.key() + "\" \"" + d->entriesIt.value() + "\" ";
       }
       parameters[parameters.length() - 1] = ')';
     }
   } else {
     parameters += '(';
-    if (!d->entries.isEmpty()) {
+    if ( !d->entries.isEmpty() ) {
       parameters += '\"' + d->entriesIt.key() + '\"';
       parameters += ' ';
-      parameters +=" {" + QByteArray::number(d->entriesIt.value().size()) + '}';
+      parameters += " {" + QByteArray::number( d->entriesIt.value().size() ) + '}';
     }
   }
 
-  if (d->entries.isEmpty()) {
+  if ( d->entries.isEmpty() ) {
     parameters += ')';
   }
 
   d->tags << d->sessionInternal()->sendCommand( command, parameters );
-//   qDebug() << "SENT: " << command << " " << parameters;
+//   kDebug() << "SENT: " << command << " " << parameters;
 }
 
 void SetMetaDataJob::handleResponse( const Message &response )
 {
-  Q_D(SetMetaDataJob);
+  Q_D( SetMetaDataJob );
 
   //TODO: Test if a server can really return more then one untagged NO response. If not, no need to OR the error codes
-  if ( !response.content.isEmpty()
-        && d->tags.contains( response.content.first().toString() ) ) {
+  if ( !response.content.isEmpty() &&
+       d->tags.contains( response.content.first().toString() ) ) {
     if ( response.content[1].toString() == "NO" ) {
       setError( UserDefinedError );
-      setErrorText( i18n("%1 failed, server replied: %2", d->m_name, response.toString().constData()) );
-      if (response.content[2].toString() == "[ANNOTATEMORE TOOMANY]" || response.content[2].toString() == "[METADATA TOOMANY]") {
+      setErrorText( i18n( "%1 failed, server replied: %2", d->m_name, response.toString().constData() ) );
+      if ( response.content[2].toString() == "[ANNOTATEMORE TOOMANY]" ||
+           response.content[2].toString() == "[METADATA TOOMANY]" ) {
         d->metaDataErrors |= TooMany;
-      } else if (response.content[2].toString() == "[ANNOTATEMORE TOOBIG]" || response.content[2].toString().startsWith("[METADATA MAXSIZE")) {
+      } else if ( response.content[2].toString() == "[ANNOTATEMORE TOOBIG]" ||
+                  response.content[2].toString().startsWith( "[METADATA MAXSIZE" ) ) { //krazy:exclude=strings
         d->metaDataErrors |= TooBig;
         d->maxAcceptedSize = -1;
-        if (response.content[2].toString().startsWith("[METADATA MAXSIZE")) { //krazy:exclude=strings
+        if ( response.content[2].toString().startsWith( "[METADATA MAXSIZE" ) ) { //krazy:exclude=strings
           QByteArray max = response.content[2].toString();
-          max.replace("[METADATA MAXSIZE",""); //krazy:exclude=doublequote_chars
-          max.replace("]", "");                //krazy:exclude=doublequote_chars
+          max.replace( "[METADATA MAXSIZE", "" ); //krazy:exclude=doublequote_chars
+          max.replace( "]", "" );                 //krazy:exclude=doublequote_chars
           d->maxAcceptedSize = max.toLongLong();
         }
-      } else if (response.content[2].toString() == "[METADATA NOPRIVATE]") {
+      } else if ( response.content[2].toString() == "[METADATA NOPRIVATE]" ) {
         d->metaDataErrors |= NoPrivate;
       }
     } else if ( response.content.size() < 2 ) {
-      setErrorText( i18n("%1 failed, malformed reply from the server.", d->m_name) );
+      setErrorText( i18n( "%1 failed, malformed reply from the server.", d->m_name ) );
     } else if ( response.content[1].toString() != "OK" ) {
       setError( UserDefinedError );
-      setErrorText( i18n("%1 failed, server replied: %2", d->m_name, response.toString().constData()) );
+      setErrorText( i18n( "%1 failed, server replied: %2", d->m_name, response.toString().constData() ) );
     }
     emitResult();
    } else if ( d->serverCapability == Metadata && response.content[0].toString() == "+" ) {
       QByteArray content = d->entriesIt.value();
       ++d->entriesIt;
-     if (d->entriesIt == d->entries.constEnd()) {
+     if ( d->entriesIt == d->entries.constEnd() ) {
        content += ')';
      } else {
-       content +=" {" + QByteArray::number(d->entriesIt.value().size()) + '}';
+       content += " {" + QByteArray::number( d->entriesIt.value().size() ) + '}';
      }
-//      qDebug() << "SENT: " << content;
+//      kDebug() << "SENT: " << content;
      d->sessionInternal()->sendData( content );
   }
 }
 
 void SetMetaDataJob::addMetaData(const QByteArray &name, const QByteArray &value)
 {
-  Q_D(SetMetaDataJob);
+  Q_D( SetMetaDataJob );
   d->entries[name] = value;
 }
 
 void SetMetaDataJob::setEntry(const QByteArray &entry)
 {
-  Q_D(SetMetaDataJob);
+  Q_D( SetMetaDataJob );
   d->entryName = entry;
 }
 
 SetMetaDataJob::MetaDataErrors SetMetaDataJob::metaDataErrors() const
 {
-  Q_D(const SetMetaDataJob);
+  Q_D( const SetMetaDataJob );
   return d->metaDataErrors;
 }
 
 #include "setmetadatajob.moc"
+
diff --git a/kimap/setmetadatajob.h b/kimap/setmetadatajob.h
index 1391ecc..3736539 100644
--- a/kimap/setmetadatajob.h
+++ b/kimap/setmetadatajob.h
@@ -68,7 +68,7 @@ class SetMetaDataJobPrivate;
 class KIMAP_EXPORT SetMetaDataJob : public MetaDataJobBase
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(SetMetaDataJob)
+  Q_DECLARE_PRIVATE( SetMetaDataJob )
 
   friend class SessionPrivate;
 
@@ -184,7 +184,7 @@ class KIMAP_EXPORT SetMetaDataJob : public MetaDataJobBase
     };
 
     // Q_DECLARE_WHATEVER_THAT_WAS missing
-    Q_DECLARE_FLAGS(MetaDataErrors, MetaDataError)
+    Q_DECLARE_FLAGS( MetaDataErrors, MetaDataError )
 
     /**
      * The metadata errors received from the server.
diff --git a/kimap/setquotajob.cpp b/kimap/setquotajob.cpp
index 9dedddd..347aeee 100644
--- a/kimap/setquotajob.cpp
+++ b/kimap/setquotajob.cpp
@@ -19,8 +19,8 @@
 
 #include "setquotajob.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 
 #include "quotajobbase_p.h"
 #include "message_p.h"
@@ -31,7 +31,7 @@ namespace KIMAP
   class SetQuotaJobPrivate : public QuotaJobBasePrivate
   {
     public:
-      SetQuotaJobPrivate( Session *session, const QString& name ) : QuotaJobBasePrivate(session, name) { }
+      SetQuotaJobPrivate( Session *session, const QString& name ) : QuotaJobBasePrivate( session, name ) { }
       ~SetQuotaJobPrivate() { }
 
       QMap<QByteArray, qint64> setList;
@@ -42,7 +42,7 @@ namespace KIMAP
 using namespace KIMAP;
 
 SetQuotaJob::SetQuotaJob( Session *session )
-  : QuotaJobBase( *new SetQuotaJobPrivate(session, i18n("SetQuota")) )
+  : QuotaJobBase( *new SetQuotaJobPrivate( session, i18n( "SetQuota" ) ) )
 {
 }
 
@@ -52,54 +52,54 @@ SetQuotaJob::~SetQuotaJob()
 
 void SetQuotaJob::doStart()
 {
-  Q_D(SetQuotaJob);
+  Q_D( SetQuotaJob );
   QByteArray s;
   s += '(';
-  for (QMap<QByteArray, qint64>::ConstIterator it = d->setList.constBegin(); it != d->setList.constEnd(); ++it ) {
-    s += it.key() + ' ' + QByteArray::number(it.value()) + ' ';
+  for ( QMap<QByteArray, qint64>::ConstIterator it = d->setList.constBegin(); it != d->setList.constEnd(); ++it ) {
+    s += it.key() + ' ' + QByteArray::number( it.value() ) + ' ';
   }
-  if (d->setList.isEmpty()) {
+  if ( d->setList.isEmpty() ) {
     s += ')';
   } else {
     s[s.length() - 1] = ')';
   }
 
-  qDebug() << "SETQUOTA " << '\"' + d->root + "\" " + s;
+  kDebug() << "SETQUOTA " << '\"' + d->root + "\" " + s;
   //XXX: [alexmerry, 2010-07-24]: should d->root be quoted properly?
-  d->tags << d->sessionInternal()->sendCommand( "SETQUOTA", '\"' + d->root + "\" " + s);
+  d->tags << d->sessionInternal()->sendCommand( "SETQUOTA", '\"' + d->root + "\" " + s );
 }
 
 void SetQuotaJob::handleResponse(const Message &response)
 {
-  Q_D(SetQuotaJob);
-  if (handleErrorReplies(response) == NotHandled) {
-    if ( response.content.size() >= 4
-         && response.content[1].toString() == "QUOTA" ) {
-      d->quota = d->readQuota(response.content[3]);
+  Q_D( SetQuotaJob );
+  if ( handleErrorReplies( response ) == NotHandled ) {
+    if ( response.content.size() >= 4 &&
+         response.content[1].toString() == "QUOTA" ) {
+      d->quota = d->readQuota( response.content[3] );
     }
   }
 }
 
-
 void SetQuotaJob::setQuota(const QByteArray &resource, qint64 limit)
 {
-  Q_D(SetQuotaJob);
+  Q_D( SetQuotaJob );
 
   d->setList[resource.toUpper()] = limit;
 }
 
 void SetQuotaJob::setRoot(const QByteArray& root)
 {
-  Q_D(SetQuotaJob);
+  Q_D( SetQuotaJob );
 
   d->root = root;
 }
 
 QByteArray SetQuotaJob::root() const
 {
-  Q_D(const SetQuotaJob);
+  Q_D( const SetQuotaJob );
 
   return d->root;
 }
 
 #include "setquotajob.moc"
+
diff --git a/kimap/setquotajob.h b/kimap/setquotajob.h
index f3fac37..ff21a29 100644
--- a/kimap/setquotajob.h
+++ b/kimap/setquotajob.h
@@ -84,6 +84,7 @@ class KIMAP_EXPORT SetQuotaJob : public QuotaJobBase
      * may create it and change the quota roots for any number of
      * existing mailboxes in an implementation-defined manner.
      *
+     * @param root the quota root to set, in bytes
      * @see GetQuotaRootJob
      */
     void setRoot( const QByteArray &root );
diff --git a/kimap/storejob.cpp b/kimap/storejob.cpp
index cf70503..0118000 100644
--- a/kimap/storejob.cpp
+++ b/kimap/storejob.cpp
@@ -19,8 +19,8 @@
 
 #include "storejob.h"
 
-#include <kdebug.h>
-#include <klocale.h>
+#include <KDE/KDebug>
+#include <KDE/KLocalizedString>
 
 #include "job_p.h"
 #include "message_p.h"
@@ -46,9 +46,9 @@ namespace KIMAP
 using namespace KIMAP;
 
 StoreJob::StoreJob( Session *session )
-  : Job( *new StoreJobPrivate(session, i18n("Store")) )
+  : Job( *new StoreJobPrivate( session, i18n( "Store" ) ) )
 {
-  Q_D(StoreJob);
+  Q_D( StoreJob );
   d->uidBased = false;
   d->mode = SetFlags;
 }
@@ -59,84 +59,86 @@ StoreJob::~StoreJob()
 
 void StoreJob::setSequenceSet( const ImapSet &set )
 {
-  Q_D(StoreJob);
+  Q_D( StoreJob );
   d->set = set;
 }
 
 ImapSet StoreJob::sequenceSet() const
 {
-  Q_D(const StoreJob);
+  Q_D( const StoreJob );
   return d->set;
 }
 
 void StoreJob::setUidBased(bool uidBased)
 {
-  Q_D(StoreJob);
+  Q_D( StoreJob );
   d->uidBased = uidBased;
 }
 
 bool StoreJob::isUidBased() const
 {
-  Q_D(const StoreJob);
+  Q_D( const StoreJob );
   return d->uidBased;
 }
 
 void StoreJob::setFlags( const MessageFlags &flags )
 {
-  Q_D(StoreJob);
+  Q_D( StoreJob );
   d->flags = flags;
 }
 
 MessageFlags StoreJob::flags() const
 {
-  Q_D(const StoreJob);
+  Q_D( const StoreJob );
   return d->flags;
 }
 
 void StoreJob::setMode( StoreMode mode )
 {
-  Q_D(StoreJob);
+  Q_D( StoreJob );
   d->mode = mode;
 }
 
 StoreJob::StoreMode StoreJob::mode() const
 {
-  Q_D(const StoreJob);
+  Q_D( const StoreJob );
   return d->mode;
 }
 
 QMap<int, MessageFlags> StoreJob::resultingFlags() const
 {
-  Q_D(const StoreJob);
+  Q_D( const StoreJob );
   return d->resultingFlags;
 }
 
 void StoreJob::doStart()
 {
-  Q_D(StoreJob);
+  Q_D( StoreJob );
 
   QByteArray parameters = d->set.toImapSequenceSet()+' ';
 
   switch ( d->mode ) {
   case SetFlags:
-    parameters+= "FLAGS";
+    parameters += "FLAGS";
     break;
   case AppendFlags:
-    parameters+= "+FLAGS";
+    parameters += "+FLAGS";
     break;
   case RemoveFlags:
-    parameters+= "-FLAGS";
+    parameters += "-FLAGS";
     break;
   }
 
-  parameters+=" (";
+  parameters += " (";
   foreach ( const QByteArray &flag, d->flags ) {
-    parameters+=flag+' ';
+    parameters += flag + ' ';
   }
-  if (!d->flags.isEmpty()) parameters.chop(1);
-  parameters+=')';
+  if ( !d->flags.isEmpty() ) {
+    parameters.chop( 1 );
+  }
+  parameters += ')';
 
-  qDebug("%s", parameters.constData());
+  kDebug() << parameters;
 
   QByteArray command = "STORE";
   if ( d->uidBased ) {
@@ -148,12 +150,12 @@ void StoreJob::doStart()
 
 void StoreJob::handleResponse( const Message &response )
 {
-  Q_D(StoreJob);
+  Q_D( StoreJob );
 
-  if (handleErrorReplies(response) == NotHandled ) {
-    if ( response.content.size() == 4
-      && response.content[2].toString()=="FETCH"
-      && response.content[3].type()==Message::Part::List ) {
+  if ( handleErrorReplies( response ) == NotHandled ) {
+    if ( response.content.size() == 4 &&
+         response.content[2].toString() == "FETCH" &&
+         response.content[3].type() == Message::Part::List ) {
 
       int id = response.content[1].toString().toInt();
       qint64 uid = 0;
@@ -163,21 +165,21 @@ void StoreJob::handleResponse( const Message &response )
       QList<QByteArray> content = response.content[3].toList();
 
       for ( QList<QByteArray>::ConstIterator it = content.constBegin();
-            it!=content.constEnd(); ++it ) {
+            it != content.constEnd(); ++it ) {
         QByteArray str = *it;
         ++it;
 
-        if ( str=="FLAGS" ) {
-          if ( (*it).startsWith('(') && (*it).endsWith(')') ) {
+        if ( str == "FLAGS" ) {
+          if ( ( *it ).startsWith( '(' ) && ( *it ).endsWith( ')' ) ) {
             QByteArray str = *it;
-            str.chop(1);
-            str.remove(0, 1);
-            resultingFlags = str.split(' ');
+            str.chop( 1 );
+            str.remove( 0, 1 );
+            resultingFlags = str.split( ' ' );
           } else {
             resultingFlags << *it;
           }
-        } else if ( str=="UID" ) {
-          uid = it->toLongLong(&uidFound);
+        } else if ( str == "UID" ) {
+          uid = it->toLongLong( &uidFound );
         }
       }
 
@@ -192,4 +194,5 @@ void StoreJob::handleResponse( const Message &response )
   }
 }
 
-#include "storejob.moc"
\ No newline at end of file
+#include "storejob.moc"
+
diff --git a/kimap/storejob.h b/kimap/storejob.h
index 7c41d90..4de2f76 100644
--- a/kimap/storejob.h
+++ b/kimap/storejob.h
@@ -36,13 +36,12 @@ typedef QList<QByteArray> MessageFlags;
 class KIMAP_EXPORT StoreJob : public Job
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(StoreJob)
+  Q_DECLARE_PRIVATE( StoreJob )
 
   friend class SessionPrivate;
 
   public:
-    enum StoreMode
-    {
+    enum StoreMode {
       SetFlags,
       AppendFlags,
       RemoveFlags
diff --git a/kimap/subscribejob.cpp b/kimap/subscribejob.cpp
index 880f977..5317f73 100644
--- a/kimap/subscribejob.cpp
+++ b/kimap/subscribejob.cpp
@@ -19,8 +19,8 @@
 
 #include "subscribejob.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 
 #include "job_p.h"
 #include "message_p.h"
@@ -32,7 +32,7 @@ namespace KIMAP
   class SubscribeJobPrivate : public JobPrivate
   {
     public:
-      SubscribeJobPrivate( Session *session, const QString& name ) : JobPrivate(session, name) { }
+      SubscribeJobPrivate( Session *session, const QString& name ) : JobPrivate( session, name ) { }
       ~SubscribeJobPrivate() { }
 
       QString mailBox;
@@ -42,7 +42,7 @@ namespace KIMAP
 using namespace KIMAP;
 
 SubscribeJob::SubscribeJob( Session *session )
-  : Job( *new SubscribeJobPrivate(session, i18n("Subscribe")) )
+  : Job( *new SubscribeJobPrivate( session, i18n( "Subscribe" ) ) )
 {
 }
 
@@ -52,20 +52,21 @@ SubscribeJob::~SubscribeJob()
 
 void SubscribeJob::doStart()
 {
-  Q_D(SubscribeJob);
-  d->tags << d->sessionInternal()->sendCommand( "SUBSCRIBE", '\"'+KIMAP::encodeImapFolderName( d->mailBox.toUtf8() )+'\"' );
+  Q_D( SubscribeJob );
+  d->tags << d->sessionInternal()->sendCommand( "SUBSCRIBE", '\"' + KIMAP::encodeImapFolderName( d->mailBox.toUtf8() ) + '\"' );
 }
 
 void SubscribeJob::setMailBox( const QString &mailBox )
 {
-  Q_D(SubscribeJob);
+  Q_D( SubscribeJob );
   d->mailBox = mailBox;
 }
 
 QString SubscribeJob::mailBox() const
 {
-  Q_D(const SubscribeJob);
+  Q_D( const SubscribeJob );
   return d->mailBox;
 }
 
 #include "subscribejob.moc"
+
diff --git a/kimap/subscribejob.h b/kimap/subscribejob.h
index f0db503..e54cf9f 100644
--- a/kimap/subscribejob.h
+++ b/kimap/subscribejob.h
@@ -32,7 +32,7 @@ class SubscribeJobPrivate;
 class KIMAP_EXPORT SubscribeJob : public Job
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(SubscribeJob)
+  Q_DECLARE_PRIVATE( SubscribeJob )
 
   friend class SessionPrivate;
 
diff --git a/kimap/unsubscribejob.cpp b/kimap/unsubscribejob.cpp
index f570987..06f0900 100644
--- a/kimap/unsubscribejob.cpp
+++ b/kimap/unsubscribejob.cpp
@@ -19,8 +19,8 @@
 
 #include "unsubscribejob.h"
 
-#include <klocale.h>
-#include <kdebug.h>
+#include <KDE/KLocalizedString>
+#include <KDE/KDebug>
 
 #include "job_p.h"
 #include "message_p.h"
@@ -32,7 +32,7 @@ namespace KIMAP
   class UnsubscribeJobPrivate : public JobPrivate
   {
     public:
-      UnsubscribeJobPrivate( Session *session, const QString& name ) : JobPrivate(session, name) { }
+      UnsubscribeJobPrivate( Session *session, const QString& name ) : JobPrivate( session, name ) { }
       ~UnsubscribeJobPrivate() { }
 
       QString mailBox;
@@ -42,7 +42,7 @@ namespace KIMAP
 using namespace KIMAP;
 
 UnsubscribeJob::UnsubscribeJob( Session *session )
-  : Job( *new UnsubscribeJobPrivate(session, i18n("Unsubscribe")) )
+  : Job( *new UnsubscribeJobPrivate( session, i18n( "Unsubscribe" ) ) )
 {
 }
 
@@ -52,20 +52,21 @@ UnsubscribeJob::~UnsubscribeJob()
 
 void UnsubscribeJob::doStart()
 {
-  Q_D(UnsubscribeJob);
-  d->tags << d->sessionInternal()->sendCommand( "UNSUBSCRIBE", '\"'+KIMAP::encodeImapFolderName( d->mailBox.toUtf8() )+'\"' );
+  Q_D( UnsubscribeJob );
+  d->tags << d->sessionInternal()->sendCommand( "UNSUBSCRIBE", '\"' + KIMAP::encodeImapFolderName( d->mailBox.toUtf8() ) + '\"' );
 }
 
 void UnsubscribeJob::setMailBox( const QString &mailBox )
 {
-  Q_D(UnsubscribeJob);
+  Q_D( UnsubscribeJob );
   d->mailBox = mailBox;
 }
 
 QString UnsubscribeJob::mailBox() const
 {
-  Q_D(const UnsubscribeJob);
+  Q_D( const UnsubscribeJob );
   return d->mailBox;
 }
 
 #include "unsubscribejob.moc"
+
diff --git a/kimap/unsubscribejob.h b/kimap/unsubscribejob.h
index f03875e..1ef8ceb 100644
--- a/kimap/unsubscribejob.h
+++ b/kimap/unsubscribejob.h
@@ -32,7 +32,7 @@ class UnsubscribeJobPrivate;
 class KIMAP_EXPORT UnsubscribeJob : public Job
 {
   Q_OBJECT
-  Q_DECLARE_PRIVATE(UnsubscribeJob)
+  Q_DECLARE_PRIVATE( UnsubscribeJob )
 
   friend class SessionPrivate;
 
